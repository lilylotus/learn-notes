location config info :
1. location [ = | ~ | ~* | ^~ ] uri { ... }
2. location @name { ... }

uri前面的方括号中的内容是可选项，解释如下：
=   开头表示精确匹配,如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。
^~  开头表示uri以某个常规字符串开头，不是正则匹配
~   开头表示区分大小写的正则匹配;
~*  开头表示不区分大小写的正则匹配
/   通用匹配, 如果没有其它匹配,任何请求都会匹配到
@   内部服务跳转

(location =) > (location 完整路径) > (location ^~ 路径) > (location ~,~* 正则顺序) > (location 部分起始路径) > (/)
首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。
当有匹配成功时候，停止匹配，按当前匹配规则处理请求。

Location 基础知识
1.location 是在 server 块中配置。
2.可以根据不同的 URI 使用不同的配置（location 中配置），来处理不同的请求。
3.location 是有顺序的，会被第一个匹配的location 处理。

请求根目录配置
指令格式：root path;
path：Nginx接收到请求以后查找资源的根目录路径
当然，还可以通过alias指令来更改location接收到的URI请求路径，指令为：

--------------------------------
Nginx反向代理和负载均衡
1.反向代理概念
1.1 正向代理的概念
正向代理，也就是传说中的代理,他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，
但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务
器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。
从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，
也隐藏了用户的资料，这取决于代理告不告诉网站。
结论就是，正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，
为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，
然后代理向原始服务器转交请求并将获得的内容返回给客户端。
客户端必须要进行一些特别的设置才能使用正向代理。

1.2 反向代理的概念
用户访问 http://www.test.com/readme，但www.test.com上并不存在readme页面，
他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。
这里所提到的 www.test.com 这个域名对应的服务器就设置了反向代理功能。

结论就是，反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。
客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)
转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。

1.3 两者区别
从用途上来讲：
正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。
正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提
供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。
另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一
个URL空间下。

从安全性来讲：
正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户
端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。

2.配置反向代理
location / {
    #设置主机头和客户端真实地址，以便服务器获取客户端真实IP
    # proxy_redirect off; # 关闭重定向
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #禁用缓存
    proxy_buffering off;
     #设置反向代理的地址
     proxy_pass http://192.168.1.1;
}

3.负载均衡
nginx 的 upstream默认是以轮询的方式实现负载均衡，每个请求按时间顺序逐一分配到不同的后端服务器，
如果后端服务器down掉，能自动剔除。

另外一种方式是ip_hash：每个请求按访问ip的hash结果分配，
每个访客固定访问一个后端服务器，可以解决session的问题。

upstream backend {
     #ip_hash;
     server 192.168.1.251;
     server 192.168.1.252;
     server 192.168.1.247;
}
server {
    listen       80;
    server_name  trffweb;
    location / {
        #反向代理的地址
        proxy_pass http://backend;

    }
}

-----------------------------------------------
log-format

$remote_addr    客户端地址
$remote_user    客户端用户名称
$time_local     访问时间和时区
$request        请求的URI和HTTP协议
$http_host      请求地址，即浏览器中你输入的地址（IP或域名）
$status         HTTP请求状态
$upstream_status    upstream状态
$body_bytes_sent    发送给客户端文件内容大小
$http_referer       url跳转来源
$http_user_agent    用户终端浏览器等信息
$ssl_protocol       SSL协议版本
$ssl_cipher         交换数据中的算法
$upstream_addr      后台upstream的地址，即真正提供服务的主机地址
$request_time       整个请求的总时间
$upstream_response_time 请求过程中，upstream响应时间

log_format  main  '$remote_addr - $remote_user [$time_local] "$request" ' access_log logs/access.log;
access_log off;