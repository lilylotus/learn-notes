### 缓存管理

常见的缓存问题：
1. 缓存穿透
   缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常处于容错的考虑，如果从缓存层查询不到数据则不写入缓存层
   缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存层保护后端存储层的意义
2. 缓存击穿
   对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。
   和缓存雪崩的区别在于这里针对某一 key 缓存，缓存雪崩则是很多 key。
   缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。
3. 缓存雪崩
   在普通的缓存系统中一般例如 redis、memcache 等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层， db 可能无法承受如此大的压力导致系统崩溃。

### 缓存更新策略

1. 先淘汰缓存，再更新数据库
   ```
   # 获取数据
   1. 先从缓存中读取数据
   2. 缓存中没有数据在从数据库中查询，有就直接返回缓存数据
   3. 从数据库中读取数据后并将数据写入缓存 (数据为空，不写入缓存)
   # 更新数据
   1. 淘汰缓存
   2. 更新数据库
   ```

   存在问题分析，读/写 并发请求操作：
      更新请求删除了缓存
      查询请求没有命中缓存
      查询请求直接从数据库中读出数据放入缓存
      更新请求更新了数据库的数据
   导致：在缓存中的数据还是老的数据，导致缓存中的数据是脏的

2. 先更新数据库，再修改缓存
   ```
   # 更新操作
   1. 先更新数据库中数据
   2. 更新缓存内容
   ```
   存在问题分析，并发更新请求操作：
      请求 1 更新数据库
      请求 2 更新数据库
      请求 2 修改缓存
      请求 1 修改缓存
   导致：数据库中数据是 2 请求设置的，而缓存数据是 1 请求设置的，导致缓存和数据库数据不一致。 

3. 先更新数据库，在淘汰缓存（经典的 [Cache Aside Pattern] 也是标准的 [design pattern]

   ```
   # 更新操作
   1. 更新数据库
   2. 淘汰缓存 （删除缓存）
   ```
   这个是推荐使用的缓存操作策略。
   存在问题分析：
   第一步数据库更新成功，第二步缓存操作失败，会导致缓存中的是脏数据，原子性无法保证。
   
   * 1. 查询请求没有命中缓存
   * 2. 查询请求从数据库中读取数据
   * 3. 更新请求更新数据库
   * 4. 更新请求删除缓存
   * 5. 查询请求把读取的老数据存入缓存
   
   导致：在缓存中的数据还是老的数据，导致缓存中的数据是脏的
   但这个 case 理论上会出现，不过实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。 而实际上数据库的写操作会比读操作慢得多，而且还要锁表， 而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

4. 先更新数据库，在淘汰缓存，并且保证原子性

   ```
   1. 更新数据库
   2. 删除缓存
   3. 其中有一步出错抛出异常，数据库数据回滚到初始状态
   ```
   
   这是 *Cache Aside Pattern* 的改进版，查询和更新请求并发的问题同样存在
   将方法置于事务中执行，缓存操作失败抛出 `RuntimeException` 会回滚事务，保证了原子性 缺点是远程操作会导致事务执行时间变长，降低并发