# SnowFlakeId
雪花算法生成分布式 id

雪花算法的原始版本是 scala 版，用于生成分布式 ID（纯数字，时间顺序）,订单编号等。 
1. 自增 ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 
2. GUID ：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。 

`0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000`
`0 -                  开始/结束时间戳差值              -  datacenterID -  workerId - 序列`

- 1 位标识，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数是0，负数是1，所以 id 一般是正数，最高位是 0
- 41 位时间截(毫秒级)，注意，41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)，
    - 开始时间截一般是我们的 id 生成器开始使用的时间，由我们程序来指定的。
    - 41 位的时间截，可以使用 69 年，年 T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69
- 10 位的数据机器位，可以部署在 1024 个节点，包括 5 位 datacenterId 和 5 位 workerId
- 12 位序列，毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生 4096 个 ID 序号

加起来刚好 64 位，为一个 Long 型。(转换成字符串后长度最多 19)

SnowFlake 的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生 ID 碰撞(由 datacenter 数据中心 ID 和 workerId 机器ID作区分)，并且效率较高，经测试，SnowFlake 每秒能够产生 26 万 ID 左右。

优点：
1. 毫秒数在高位，自增序列在低位，整个 ID 都是趋势递增的。
2. 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。
3. 可以根据自身业务特性分配 bit 位，非常灵活。

缺点：

1. 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。