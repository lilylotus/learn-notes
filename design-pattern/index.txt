提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案
23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解

1. 根据目的来分
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。

创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。
结构型模式：用于描述如何将类或对象按某种布局组成更大的结构
行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责

单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言
它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：
依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。

在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。
关联（Association）关系是对象之间的一种引用关系，关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系
关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。

开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。
1. 对软件测试的影响
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。
也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
每个类尽量提供接口或抽象类，或者两者都具备。
变量的声明类型尽量是接口或者是抽象类。
任何类都不应该从具体类派生。
使用继承时尽量遵循里氏替换原则。


7 种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和合成复用原则
这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。
开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；
里氏替换原则告诉我们不要破坏继承体系；
依赖倒置原则告诉我们要面向接口编程；
单一职责原则告诉我们实现类要职责单一；
接口隔离原则告诉我们在设计接口的时候要精简单一；
迪米特法则告诉我们要降低耦合度；
合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。

依赖关系（Dependency），使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。
关联关系（Association），分为双向关联和单向关联两种。其中，双向关联可以用带两个箭头或者没有箭头的实线来表示，单向关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。还可以在关联线的两端标注角色名，补充说明它们的角色。
聚合关系（Aggregation），用带空心菱形的实线来表示，菱形指向整体。
组合关系（Composition），用带实心菱形的实线来表示，菱形指向整体。
泛化关系（Generalization），用带空心三角箭头的实线来表示，箭头从子类指向父类。
实现关系（Realization），用带空心三角箭头的虚线来表示，箭头从实现类指向接口。


一、一句话概括工厂模式
 简单工厂：一个工厂类，一个产品抽象类。
 工厂方法：多个工厂类，一个产品抽象类。
 抽象工厂：多个工厂类，多个产品抽象类。
二、生活中的工厂模式
 简单工厂类：一个麦当劳店，可以生产多种汉堡。
 工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
 抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。

 简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。

二. 建造者模式，又称生成器模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
三个角色：建造者、具体的建造者、监工、使用者（严格来说不算）
 建造者角色：定义生成实例所需要的所有方法；
 具体的建造者角色：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；
 监工角色：定义使用建造者角色中的方法来生成实例的方法；
 使用者：使用建造者模式。
注意：定义中“将一个复杂的构建过程与其表示相分离”，表示并不是由建造者负责一切，而是由监工负责控制（定义）一个复杂的构建过程，由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。


三. 桥接模式：Bridge Pattern
将抽象和实现放在两个不同的类层次中，使它们可以独立地变化。——《Head First 设计模式》
将类的功能层次结构和实现层次结构相分离，使二者能够独立地变化，并在两者之间搭建桥梁，实现桥接。—— 《图解设计模式》
类的功能层次结构：父类具有基本功能，在子类中增加新的功能；
类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口；
桥接模式中有四个角色：
抽象化角色：使用实现者角色提供的接口来定义基本功能接口。
持有实现者角色，并在功能接口中委托给它，起到搭建桥梁的作用；
注意，抽象化角色并不是指它就是一个抽象类，而是指抽象了实现。
改善后的抽象化角色：作为抽象化角色的子类，增加新的功能，也就是增加新的接口（方法）；与其构成类的功能层次结构；
实现者角色：提供了用于抽象化角色的接口；它是一个抽象类或者接口。
具体的实现者角色：作为实现者角色的子类，通过实现具体方法来实现接口；与其构成类的实现层次结构。
如果抽象和实现两者做不到独立地变化，就不算桥接模式。

四. JDK 自带的动态代理
java.lang.reflect.Proxy:生成动态代理类和对象；
java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对真实角色的代理访问。
每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。

Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 
如果是private或是final类修饰的方法,则不会被重写。
CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。
通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。

CGLIB 原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。
CGLIB 底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。
CGLIB缺点：对于final方法，无法进行代理。
