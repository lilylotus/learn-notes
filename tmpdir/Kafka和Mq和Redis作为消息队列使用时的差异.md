**问题**

Kafka是作为新一代的消息系统，*rabbitmq* 是比较成熟消息系统，而 *redis* 也可以发布订阅了，那么这三者有何异同？
作为消息队列来说，企业中选择 rabbitmq 的还是多数，因为像 Rabbit，Rocket 等 mq 中间件都属于很成熟的产品，性能一般但可靠性较强，而 kafka 原本设计的初衷是日志统计分析，现在基于大数据的背景下也可以做运营数据的分析统计，而 redis 的主要场景是内存数据库，作为消息队列来说可靠性太差，而且速度太依赖网络 IO，在服务器本机上的速度较快，且容易出现数据堆积的问题，在比较轻量的场合下能够适用。希望有更专业的人来总结总结。



### 一. 资料文档

| 语言     | 资料量 | 资料                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| Kafka    | 一般   | 有 kafka 作者自己写的书，网上资料也有一些                    |
| rabbitmq | 多     | 有一些不错的书，网上资料多                                   |
| zeromq   | 少     | 没有专门写 zeromq 的书，网上的资料多是一些代码的实现和简单介绍 |
| rocketmq | 少     | 没有专门写 rocketmq 的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述 |
| activemq | 多     | 没有专门写 activemq 的书，网上资料多                         |

### 二. 开发语言

| mq 名称  | 使用语言 |
| -------- | -------- |
| Kafka    | Scala    |
| rabbitmq | Erlang   |
| zeromq   | C        |
| rocketmq | Java     |
| activemq | Java     |

### 三. 支持的协议

| mq 名称  | 支持的协议                         |
| -------- | ---------------------------------- |
| Kafka    | 自己定义的一套...（基于TCP）       |
| Rabbitmq | AMQP                               |
| Zeromq   | TCP, UDP                           |
| rocketmq | 自己定义的一套...                  |
| activemq | OpenWIre, STOPMP, REST, XMPP, AMQP |

### 四. 消息存储

1. Kafka：内存、磁盘、数据库。支持大量堆积。

kafka 的最小存储单元是分区，一个 topic 包含多个分区，kafka 创建主题时，这些分区会被分配在多个服务器上，通常一个 broker 一台服务器。

分区首领会均匀地分布在不同的服务器上，分区副本也会均匀的分布在不同的服务器上，确保负载均衡和高可用性，当新的 broker 加入集群的时候，部分副本会被移动到新的 broker 上。

根据配置文件中的目录清单，kafka 会把新的分区分配给目录清单里分区数最少的目录。

默认情况下，分区器使用轮询算法把消息均衡地分布在同一个主题的不同分区中，对于发送时指定了key的情况，会根据 key 的 hashcode 取模后的值存到对应的分区中。

2. rabbitmq：内存、磁盘。支持少量堆积。

rabbitmq 的消息分为持久化的消息和非持久化消息，不管是持久化的消息还是非持久化的消息都可以写入到磁盘。

持久化的消息在到达队列时就写入到磁盘，并且如果可以，持久化的消息也会在内存中保存一份备份，这样可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只存在于内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存。

引入镜像队列机制，可将重要队列“复制”到集群中的其他 broker 上，保证这些队列的消息不会丢失。配置镜像的队列，都包含一个主节点 master 和多个从节点 slave,如果 master 失效，加入时间最长的 slave 会被提升为新的master，除发送消息外的所有动作都向 master 发送，然后由 master 将命令执行结果广播给各个 slave，rabbitmq会让 master 均匀地分布在不同的服务器上，而同一个队列的 slave 也会均匀地分布在不同的服务器上，保证负载均衡和高可用性。

3. zeromq：消息发送端的内存或者磁盘中。不支持持久化。

4. rocketmq：磁盘。支持大量堆积。

commitLog 文件存放实际的消息数据，每个 commitLog 上限是1G，满了之后会自动新建一个commitLog文件保存数据。ConsumeQueue队列只存放offset、size、tagcode，非常小，分布在多个broker上。ConsumeQueue相当于 CommitLog 的索引文件，消费者消费时会从consumeQueue中查找消息在commitLog中的offset，再去commitLog 中查找元数据。

ConsumeQueue 存储格式的特性，保证了写过程的顺序写盘（写 CommitLog 文件），大量数据IO都在顺序写同一个 commitLog，满 1G 了再写新的。加上 rocketmq 是累计 4K 才强制从 PageCache 中刷到磁盘（缓存），所以高并发写性能突出。

5. activemq：内存、磁盘、数据库。支持少量堆积。





