Docker 包括 3 个基本概念：
1. 镜像 (image)
镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，由多层文件系统联合组成

2. 容器 (Container)
3. 仓库 (Repository)

镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。

虚悬镜像 (dangling):
特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>
查看此类镜像：
docker image ls -f dangling=true
删除此类镜像：
docker image prune

=================================================

1. 拉取镜像
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

2. 查看 docker 的镜像大小
docker system df

3. 查看本地镜像：
docker image ls [镜像名称]
新增过滤条件： docker image ls -f since=ubuntu:18.04 ( -f label=version=0.01)
格式化显示：
docker image ls --format "{{.ID}}: {{.Repository}}"
docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"

4. 删除镜像
docker image rm [选项] <镜像1> [<镜像2> ...]
注意：<镜像> 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要
删除行为分为两类，一类是 Untagged ，另一类是 Deleted 。
镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。
所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。

docker image rm $(docker image ls -q redis)

5. 镜像构成
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]

运行一个容器的时候（如果不使用卷的话），任何文件修改都会被记录于容器存储层里。
Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。
在原有镜像的基础上，再叠利用 commit 理解镜像构成加上容器的存储层，并构成新的镜像。
以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。

docker commit \
--author "Tao Wang <twang2218@gmail.com>" \
--message "修改了默认网页" \
webserver \
nginx:v2

6. 查看镜像内的历史记录
docker history <容器ID或容器名> 具体查看镜像内的历史记录

7. Dockerfile 定制镜像
docker build [选项] <上下文路径/URL/->

示例：在空的文件夹下建立 Dockerfile
FROM nginx
RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html
在: docker build -t <新镜像:标签> . (注意最后有个点)

注意： FROM 是必须的，指定构建的基础镜像
特殊基础镜像 ( scratch )，空白镜像可不以任何镜像为基础， ( FROM debian:stretch )

RUN 指令：来执行命令行命令
>shell 格式： RUN <命令> ，就像直接在命令行中输入的命令一样
RUN echo '<h1>Hello,Dcoker!</h1>' > /usr/share/nginx/html/index.html

>exec 格式： RUN ["可执行文件", "参数1", "参数2"] ，这更像是函数调用中的格式。

注意： Dcokerfile 在每一指令会建立一层，RUN 指令也不列外，每个 RUN 指令就是新建立了一层。
Union FS 有最大的层数限制，如： AUFS 不得超过 127 层。
因此要把 RUN 命令连起来写，如：
RUN buildDeps='gcc libc6-dev make wget' \
&& apt-get update \
&& apt-get install -y $buildDeps \
&& wget -0 redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
&& mkdir -p /usr/src/redis \
&& tar -zxf redis.tar.gz -C /usr/src/redis --strip-components=1 \
&& make -C /usr/src/redis \
&& make -C /usr/src/redis install \
&& rm -rf /var/lib/apt/list/* \
&& rm redis.tar.gz \
&& rm -rf /usr/src/redis \
&& apt-get purge -y --auto-remove $buildDeps

>>>> 最后一定要清理掉无关文件

8. 镜像构建的上下文 ( Context )
docker build 命令最后有一个 . 。 . 表示当前目录，而 Dockerfile 就在当前目录，
因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。

上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，
docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。
这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

9. 构建命令：
9.1 COPY 复制文件：
COPY [--chown=<user>:<group>] <源路径>... <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]

9.2 ADD 高级复制文件
遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。

9.3 CMD 容器启动命令：
shell 格式： CMD <命令>
exec 格式： CMD ["可执行文件", "参数1", "参数2"...] 参数列表格式： CMD ["参数1", "参数2"...] 。
在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。