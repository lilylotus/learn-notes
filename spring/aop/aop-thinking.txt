一. AOP 术语
1. 切面(Aspect):
	横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象，把横切关注点的代码抽象到切面的类中
2. 通知(Advice):
	切面必须要完成的工作,就是功能对应的方法
3. 目标(Target):
	被通知的对象
4. 代理(Proxy):
	向目标对象应用通知之后创建的对象
5. 连接点（Joinpoint）：
	程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。
	连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。方位为该方法执行前的位置
6. 切点（pointcut）：

二. AspectJ
1. Spring中启用AspectJ注解支持
	1.1 Spring应用中使用AspectJ注解,必须在classpath下包含AspectJ类库
	1.2 在Bean配置文件中定义一个空的 XML 元素<aop:aspectj-autoproxy>
	1.3 SpringIOC 容器侦测到 Bean 配置文件中的<aop:aspectj-autoproxy>元素时,
		会自动为与AspectJ切面匹配的Bean创建代理.

2. 用 AspectJ 注解声明切面
	2.1 切面只是一个带有@Aspect注解的 Java类.
	2.2 AspectJ支持5种类型的通知注解:
      @Before: 前置通知,在方法执行之前执行
      @After: 后置通知,在方法执行之后执行
      @AfterRunning:返回通知,在方法返回结果之后执行
      @AfterThrowing:异常通知,在方法抛出异常之后
      @Around: 环绕通知,围绕着方法执行

------------------------------------------------------------------------
面向切面编程(也叫面向方面编程)：Aspect Oriented Programming(AOP)
1: 前置通知；@Before
在方法执行之前执行的通知。
2: 后置通知；@After
后置通知是在连接点完成之后执行的，切面返回结果或者抛出异常的时候，
后置通知记录了方法依然会执行。一个切面可以包括一个或者多个通知。
3: 环绕通知；@Around
环绕通知需要携带ProceedingJoinPoint 这个类型的参数，
环绕通知类似于动态代理的全过程ProceedingJoinPoint类型的参数可以决定是否
执行目标函数环绕通知必须有返回值。其实就是包含了所有通知的全过程
4: 返回通知；@AfterReturning
方法正常执行通过之后执行的通知叫做返回通知。
此时注意，不仅仅使用JoinPoint获取连接点信息，同时要在返回通知注解里写入，resut="result"。
在切面方法参数中加入Object result,用于接受返回通知的返回结果。
如果目标方法方法是void返回类型则返回NULL
5: 异常通知；@AfterThrowing
在执行目标方法过程中，如果方法抛出异常则会走此方法。
和返回通知很相似，在注解中加入，throwing="ex"，在切面方法中加入Exection ex用于接受异常信息

<!-- 配置aspect 自动为匹配的类 产生代理对象 -->
<aop:aspectj-autoproxy>

-------------------------------------------------------------------------
1. JoinPoint 对象:
Signature getSignature();  该对象中可以获取到目标方法名,所属类的Class等信息
Object[] getArgs(); 获取传入目标方法的参数对象
Object getTarget(); 获取被代理的对象
Object getThis();   获取代理对象

2. ProceedingJoinPoint对象
ProceedingJoinPoint对象是JoinPoint的子接口,该对象只用在@Around的切面方法中,

Object proceed() throws Throwable //执行目标方法
Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法

在Spring配置文件中，所以AOP相关定义必须放在<aop:config>标签下，
该标签下可以有<aop:pointcut>、<aop:advisor>、<aop:aspect>标签，配置顺序不可变。
<aop:pointcut>：用来定义切入点，该切入点可以重用；
<aop:advisor>：用来定义只有一个通知和一个切入点的切面；
<aop:aspect>：用来定义切面，该切面可以包含多个切入点和通知，
而且标签内部的通知和切入点定义是无序的；和advisor的区别就在此，
advisor只包含一个通知和一个切入点。

==================================================
1. Spring所支持的AspectJ表达式可分为四类:
	方法切点函数：通过描述目标类方法信息定义连接点。
	方法参数切点函数：通过描述目标类方法入参信息定义连接点。
	目标类切点函数：通过描述目标类类型信息定义连接点。
	代理类切点函数：通过描述代理类信息定义连接点。

2. 常见的AspectJ表达式函数：
	execution()：满足匹配模式字符串的所有目标类方法的连接点
	@annotation()：任何标注了指定注解的目标方法链接点
	args()：目标类方法运行时参数的类型指定连接点
	@args()：目标类方法参数中是否有指定特定注解的连接点
	within()：匹配指定的包的所有连接点
	target()：匹配指定目标类的所有方法
	@within()：匹配目标对象拥有指定注解的类的所有方法
	@target()：匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解
	this()：匹配当前AOP代理对象类型的所有执行方法
	最常用的是：execution(<修饰符模式>?<返回类型模式><方法名模式>(<参数模式>)<异常模式>?)
		切点函数，可以满足多数需求。

1.通知(Advice):
通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。
2.连接点(Joinpoint):
程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。
3.切入点(Pointcut)
通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，Spring中允许我们方便的用正则表达式来指定
4.切面(Aspect)
通知和切入点共同组成了切面：时间、地点和要发生的“故事”
5.引入(Introduction)
引入允许我们向现有的类添加新的方法和属性(Spring提供了一个方法注入的功能）
6.目标(Target)
即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）
7.代理(proxy)
应用通知的对象，详细内容参见设计模式里面的代理模式
8.织入(Weaving)
把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:
(1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器
(2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码
(3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术

<aop:advisor> 定义一个AOP通知者
<aop:after> 后通知
<aop:after-returning> 返回后通知
<aop:after-throwing> 抛出后通知
<aop:around> 周围通知
<aop:aspect>定义一个切面
<aop:before>前通知
<aop:config>顶级配置元素，类似于<beans>这种东西
<aop:pointcut>定义一个切点

---------------------------------------------------
1. AOP 配置
<aop:config>
    <!-- 切面 -->
    <aop:aspect id="time" ref="timeHandler" order="1">
        <!--<aop:pointcut id="addAllMethod" expression="execution(* cn.nihility.aop.HelloWorld.*(..))" />-->
        <!-- 切点 -->
        <aop:pointcut id="addAllMethod" expression="execution(* cn.nihility.aop.HelloWorld.print*(..))" />
        <!-- 连接通知方法 -->
        <aop:before method="pritTime" pointcut-ref="addAllMethod" />
        <aop:after method="pritTime" pointcut-ref="addAllMethod" />
    </aop:aspect>
</aop>