1. 通配符
    * : 匹配任意数量的字符
    + : 匹配制定类及其子类
    .. : 匹配任意数量的子包或者参数
2. 操作符
    && ：
    || ：
    !  :
3. 指示器 (designators)

    匹配方法 ： execution() --- 常用
    匹配注解 :
        @target()
        @args()
        @within()
        @annotation()
    匹配包/类型 : within()
    匹配对象 :
        this()
        bean()
        target()
    匹配参数 :
        args()

例子：
1. within
    // 匹配 ProductService 类中的所有方法
    @Pointcut("within(cn.nihility.service.ProductService)")
    // 匹配 cn.nihility 包及其子包下的所有类的方法
    @Pointcut("within(cn.nihility..*)")

2. 匹配对象
    /**
     * public class DemoDAO implements IDao {}
     */
    // 匹配 AOP 对象的目标对象为指定类型的方法， 即 DemoDAO的AOP代理对象的方法
    @Pointcut("this(cn.nihility.DemoDAO")
    // 匹配实现 IDao 借口的目标对象(而不是 AOP 代理后的对象)的方法，这里即是DemoDAO的方法
    @Pointcut("target(cn.nihility.IDao)")
    // 匹配所有以 Service 结尾的 Bean 中的方法
    @Pointcut("bean(*Service)")

3. 匹配注解
    // 匹配标注有 AdminOnly 的注解方法
    @Pointcut("@annotation(cn.nihility.anno.AdminOnly)")
    // 匹配标注有 Bate 的类下的方法，要求的Annotation的RetentionPolicy级别为CLASS
    @Pointcut("@within(cn.nihility.anno.Bate)")
    // 匹配标注有 Repository 的类下方法， 要求的Annotation的RetentionPolicy级别为RUNTIME
    @Pointcut("@target(cn.nihility.anno.Repository)")
    // 匹配传入的参数类标注有 Repository 的注解方法
    @Pointcut("@args(cn.nihility.anno.Repository")

4. execution 表达式
execution(* com.sample.service.impl..*.*(..))
    1、execution(): 表达式主体。
    2、第一个*号：表示返回类型，*号表示所有的类型。
    3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包
        com.sample.service.impl包、子孙包下所有类的方法。
    4、第二个*号：表示类名，*号表示所有的类。
    5、*(..):最后这个星号表示方法名，*号表示所有的方法，
        后面括弧里面表示方法的参数，两个句点表示任何参数。

============================================================
JoinPoint的用法

1. JoinPoint 对象
JoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,
就可以获取到封装了该方法信息的JoinPoint对象.
private void doBefore(JoinPoint joinpoint) { ... }

Signature getSignature();
获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息
Object[] getArgs(); 获取传入目标方法的参数对象
Object getTarget(); 获取被代理的对象
Object getThis();   获取代理对象

2. ProceedingJoinPoint对象
ProceedingJoinPoint对象是JoinPoint的子接口,该对象只用在@Around的切面方法中

Object proceed() throws Throwable //执行目标方法
Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法


=======================================================
@Before("declareJoinPointerExpression()")
public void beforeMethod(JoinPoint joinPoint){
    System.out.println("目标方法名为:" + joinPoint.getSignature().getName());
    System.out.println("目标方法所属类的简单类名:" +        joinPoint.getSignature().getDeclaringType().getSimpleName());
    System.out.println("目标方法所属类的类名:" + joinPoint.getSignature().getDeclaringTypeName());
    System.out.println("目标方法声明类型:" + Modifier.toString(joinPoint.getSignature().getModifiers()));
    //获取传入目标方法的参数
    Object[] args = joinPoint.getArgs();
    for (int i = 0; i < args.length; i++) {
        System.out.println("第" + (i+1) + "个参数为:" + args[i]);
    }
    System.out.println("被代理的对象:" + joinPoint.getTarget());
    System.out.println("代理对象自己:" + joinPoint.getThis());
}

@Around("declareJoinPointerExpression()")
public Object aroundMethod(ProceedingJoinPoint pjd){
    Object result = null;
    try {
        //前置通知
        System.out.println("目标方法执行前...");
        //执行目标方法
        //result = pjd.proeed();
        //用新的参数值执行目标方法
        result = pjd.proceed(new Object[]{"newSpring","newAop"});
        //返回通知
        System.out.println("目标方法返回结果后...");
    } catch (Throwable e) {
        //异常通知
        System.out.println("执行目标方法异常后...");
        throw new RuntimeException(e);
    }
    //后置通知
    System.out.println("目标方法执行后...");
    return result;
}