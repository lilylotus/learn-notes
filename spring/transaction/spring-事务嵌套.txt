spring所有的事务管理策略类都继承自 [org.springframework.transaction.PlatformTransactionManager] 接口

事务隔离级别
隔离级别是指若干个并发的事务之间的隔离程度。
TransactionDefinition 接口中定义了五个表示隔离级别的常量：
1. ISOLATION_DEFAULT
默认值，使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是 ISOLATION_READ_COMMITTED。
2. ISOLATION_READ_UNCOMMITTED
一个事务可以读取另一个事务修改但还没有提交的数据。
该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。
3. ISOLATION_READ_COMMITTED
一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
4. ISOLATION_REPEATABLE_READ
一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。
5. ISOLATION_SERIALIZABLE
所有的事务依次逐个执行，事务之间就完全不可能产生干扰，该级别可以防止脏读、不可重复读以及幻读。
但是这将严重影响程序的性能。通常情况下也不会用到该级别。

==============================================================
事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring支持以下7种事务传播行为
支持当前事务的情况:
PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务，就加入到这个事务中。这是最常见的选择。
PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。

不支持当前事务的情况：
PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

其他情况：
PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

==============================================================
PROPAGATION_REQUIRES_NEW
启动一个新的,不依赖于环境的 "内部" 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务,
它拥有自己的隔离范围, 自己的锁等等.当内部事务开始执行时,外部事务将被挂起,内务事务结束时,外部事务将继续执行

PROPAGATION_NESTED
开始一个 "嵌套的" 事务,它是已经存在事务的一个真正的子事务.嵌套事务开始执行时,它将取得一个 savepoint.
如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交.
   
PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于,PROPAGATION_REQUIRES_NEW 完全是一个新的事务,
而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back.

-------------------------------------------
NESTED 和 REQUIRED 修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。
但是 REQUIRED 是加入外围方法事务，所以和外围事务同属于一个事务，
一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。
NESTED 是外围方法的子事务，有单独的保存点，所以 NESTED 方法抛出异常被回滚，不会影响到外围方法的事务。

NESTED 和 REQUIRES_NEW 都可以做到内部方法事务回滚而不影响外围方法事务。
但是因为 NESTED 是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。
而 REQUIRES_NEW 是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。

================================================================
回滚规则（定义事务回滚规则）
这些规则定义了哪些异常会导致事务回滚而哪些不会。
默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）
但可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。
还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。

注意： RuntimeException -> 运行时异常会回滚，不管是否有 catch 到异常。
