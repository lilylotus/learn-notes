事务有四个特性：ACID
原子性（Atomicity）：
    事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
一致性（Consistency）：
    一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。
隔离性（Isolation）：
    可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。
持久性（Durability）：
    一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。

说明了Spring的事务支持默认只对运行期异常(RuntimeException)进行回滚
throw new RuntimeException("运行期例外");

===========================================================================
@Transactional
@Transactional(propagation=Propagation.REQUIRED,rollbackFor=Exception.class,timeout=1,isolation=Isolation.DEFAULT)
（1）把这个注解放在类名称上面了，这样你配置的这个@Transactional 对这个类中的所有public方法都起作用
（2）方法名上，只对这个方法有作用，同样必须是public的方法

事务的传播性：@Transactional(propagation=Propagation.REQUIRED)  如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)
事务的超时性：@Transactional(timeout=30) //默认是30秒    注意这里说的是事务的超时性而不是Connection的超时性，这两个是有区别的   
事务的隔离级别：@Transactional(isolation = Isolation.READ_UNCOMMITTED)  读取未提交数据(会出现脏读, 不可重复读) 基本不使用
回滚：
指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)
指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})
该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。
只读：@Transactional(readOnly=true)
该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。

<!-- 定义事务管理器 -->
<bean id="transactionManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
</bean>
<!-- 下面使用aop切面的方式来实现 -->
<tx:advice id="TestAdvice" transaction-manager="transactionManager">
    <!--配置事务传播性，隔离级别以及超时回滚等问题 -->
    <tx:attributes>
        <tx:method name="save*" propagation="REQUIRED" />
        <tx:method name="del*" propagation="REQUIRED" />
        <tx:method name="update*" propagation="REQUIRED" />
        <tx:method name="add*" propagation="REQUIRED" />
        <tx:method name="*" rollback-for="Exception" />
    </tx:attributes>
</tx:advice>
<aop:config>
    <!--配置事务切点 -->
    <aop:pointcut id="services"
        expression="execution(* com.website.service.*.*(..))" />
    <aop:advisor pointcut-ref="services" advice-ref="TestAdvice" />
</aop:config>

其中tx:attributes中设置了事务的传播性，隔离级别以及那种问题能进行回滚超时等这些问题，也就是你自己按照业务需求定制一个事务来满足你的业务求
注意一下，在tx:method中配置了rollback_for 中配置的Exception 这个是运行时的异常才会回滚不然其他异常是不会回滚的！
throw new RuntimeException();

如<tx:method name="save*" propagation="REQUIRED"/>
其中*为通配符，即代表以save为开头的所有方法，即表示符合此命名规则的方法作为一个事务。
propagation="REQUIRED"代表支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

<tx:method name="delete*" propagation="REQUIRED" isolation="DEFAULT" read-only="false"/>
tx:method的属性:
name 是必须的,表示与事务属性关联的方法名(业务方法名),对切入点进行细化
通配符（*）可以用来指定一批关联到相同的事务属性的方法。如：'get*'、'handle*'、'on*Event'等等.
propagation  不是必须的 ，默认值是REQUIRED 表示事务传播行为, 包括REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER,NESTED
isolation    不是必须的 默认值DEFAULT 表示事务隔离级别(数据库的隔离级别) 
timeout      不是必须的 默认值-1(永不超时)  表示事务超时的时间（以秒为单位） 
read-only    不是必须的 默认值false不是只读的  表示事务是否只读？ 
rollback-for 不是必须的   表示将被触发进行回滚的 Exception(s)；以逗号分开。如：'com.foo.MyBusinessException,ServletException' 
no-rollback-for 不是必须的  表示不被触发进行回滚的 Exception(s)；以逗号分开。如：'com.foo.MyBusinessException,ServletException'
任何 RuntimeException 将触发事务回滚，但是任何 checked Exception 将不触发事务回滚

spring事务的几种传播特性：
1. PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启
2. PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行
3. PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
4. PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
5. PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务。
6. PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常
7. PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 
      则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行

Spring事务的隔离级别
1. ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别,另外四个与JDBC的隔离级别相对应
2. ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据,这种隔离级别会产生脏读，不可重复读和幻像读。
3. ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据
4. ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读,它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。
5. ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行,除了防止脏读，不可重复读外，还避免了幻像读
===========================================================================  

===========================================================================     
1. 事务之间的隔离程度  
TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。
对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。
TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。
该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。
TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。
该级别可以防止脏读，这也是大多数情况下的推荐值。

TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。
该级别可以防止脏读和不可重复读。
TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

2. 事务的传播行为
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

3. @Transactional属性
value   String  可选的限定描述符，指定使用的事务管理器
propagation enum: Propagation   可选的事务传播行为设置
isolation   enum: Isolation 可选的事务隔离级别设置
readOnly    boolean 读写或只读事务，默认读写
timeout int (in seconds granularity)    事务超时时间设置
rollbackFor Class对象数组，必须继承自Throwable    导致事务回滚的异常类数组
rollbackForClassName    类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组
noRollbackFor   Class对象数组，必须继承自Throwable    不会导致事务回滚的异常类数组
noRollbackForClassName  类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组
===========================================================================