===公共配置

<!-- 1. 加载配置文件 -->
<context:property-placeholder
	file-encoding="UTF-8" location="classpath:properties/mysql.properties" />
<!-- 2. 配置数据库链接池 -->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
	<property name="driverClass" value="${jdbc.classDriver}" />
	<property name="jdbcUrl" value="${jdbc.url}" />
	<property name="user" value="${jdbc.user}" />
	<property name="password" value="${jdbc.password}" />
</bean>
<!-- 3. 配置事物管理 -->
<bean id="transactionManager"
	class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"></property>
</bean>

1. 使用 Spring 的事务管理模板
	<!-- 4. 配置事物管理模板 -->
	<bean id="transactionTemplate"
		class="org.springframework.transaction.support.TransactionTemplate">
		<property name="transactionManager" ref="transactionManager"></property>
	</bean>
	<!-- 5. 配置事务 beans -->
	<bean id="txDao" class="cn.nihility.spring.mvc.demo.tx.dao.impl.TransferDaoImpl">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	<bean id="txService"
		class="cn.nihility.spring.mvc.demo.tx.service.impl.TransferServiceImpl">
		<property name="transferDao" ref="txDao"></property>
		<property name="transactionTemplate" ref="transactionTemplate"></property>
	</bean>

2. 使用 Spring 的事务代理类
	<!-- 5. 配置一个代理事务管理 -->
	<bean id="proxyTransactionService" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
		<!-- 配置目标类 -->
		<property name="target" ref="txService"/>
		<!-- 配置事务管理器 -->
		<property name="transactionManager" ref="transactionManager"/>
		<!-- 配置事务的属性管理 -->
		<property name="transactionAttributes">
			<props>
				<!--  
					配置事务的 acid
					key ： Attribute
					方法 : 事务属性
	               * PROPAGATION   :事务的传播行为
	               * ISOTATION     :事务的隔离级别
	               * readOnly      :只读
	               * -EXCEPTION    :发生哪些异常回滚事务
	               * +EXCEPTION    :发生哪些异常不回滚事务					
				-->
				<prop key="transfer">PROPAGATION_REQUIRED</prop>
			</props>
		</property>
	</bean>

3. 使用 AOP 切面 事务增强 (类中不用在写什么字段)
	<!-- 5. 建议声明 -->
	<tx:advice id="txServiceAdvice" transaction-manager="transactionManager">
		<!-- 声明属性 -->
		<tx:attributes>
			<tx:method name="transfer" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
	<!-- 6. AOP 管理 -->
	<aop:config>
		<!-- 切面 -->
		<aop:pointcut expression="execution(* cn.nihility.spring.mvc.demo.tx.service.impl..*(..))" id="transferPoint"/>
		<!-- 事务增强 -->
		<aop:advisor advice-ref="txServiceAdvice" pointcut-ref="transferPoint"/>
	</aop:config>	

4. 注解扫描的事务
	<!-- 3. 扫描注解类 -->
	<context:component-scan base-package="cn.nihility.spring.mvc.demo.tx"></context:component-scan>
	<!-- 4. 开启注解注入 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>

	@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
	public void transfer(String outName, String inName, Integer money)

---------------------------------------------
事务属性介绍
1. 事务有四个特性：ACID
	原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
	一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。
	隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。
	持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。

2. 事务的传播行为（propagation behavior）
	PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
	PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。
	PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。
	PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起。
	PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
	PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常。
	PROPAGATION_NESTED--如果当前存在事务，则在嵌套事务内执行。
		如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。

3. 隔离级别（isolation level）
脏读（Dirty reads）
	——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。
不可重复读（Nonrepeatable read）
	——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。
幻读（Phantom read）
	——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。

不可重复读与幻读的区别 
	不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 
	幻读的重点在于新增或者删除： 同样的条件, 第1次和第2次读出来的记录数不一样 
3.1 隔离级别
ISOLATION_DEFAULT	
	使用后端数据库默认的隔离级别
ISOLATION_READ_UNCOMMITTED
	最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
ISOLATION_READ_COMMITTED
	允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
ISOLATION_REPEATABLE_READ
	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
ISOLATION_SERIALIZABLE
	最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的