一. 变量的定义与赋值
Bash变量在使用时直接定义 如： var="this is a var"

注意:
    ＝ 两边不能有空格！否则就是语法错误了。
    Bash变量命名只能使用字母，下划线和数字，并且不能以数字开头。

变量的引用 : echo $var 或者 echo ${var}
1. 变量名前面加 $ 符号
2. ${var_name}的形式

注意''和""的区别：
'' ：单引号里的任何字符都会原样输出，单引号中对变量引用是无效的，且单引号中不能出现单引号（对单引号使用转义符也不行）；
"" ：双引号里可以引用变量，可以出现转义字符。

只读变量 ： 使用 readonly 命令可以将变量限定为只读变量
var_a="hello"
readonly var_b
var_b="World"

删除变量 :  unset 命令可以删除变量，但是不能删除只读变量。变量被删除后不能再次使用。
var="hello"
unset var
echo ${var} # 变量my_var已被删除，没有任何输出

变量的类型: 在Bash中，并不对变量区分类型。Bash变量都是字符串。
但是依赖于上下文，Bash也允许比较操作和算术操作。决定这些的关键因素是变量中的值是否只有数字，
只有当变量是纯数字时，该变量才是“数字类型的”，否则就是字符串类型的。
另外，注意Bash中的数字默认的是十进制，八进制需要以0开头，十六进制以0x开头。

1. 纯数字变量是“数字变量”
2. 数字＋字符串：字符串变量，字符串变量不能进行数学运算
3. 空变量+数字：数字变量
4. 未定义的变量+数字：数字变量

-------------------------------------
NOTE :
使用if语句的时候进行判断如果是进行数值类的判断，建议使用let(())进行判断，
对于字符串等使用test[ ] or [[ ]] 进行判断
(())中变量是可以不使用$来引用的
也可使用 test -f "$file" 来做判断

要取结果或输出，都要用 $( ) 或反引号 ` `
反引号 ` ` 和 $( ) 缺陷也相同，没回车换行，容易把多行合并
wc-l常与$( )合用取其输出，计算行数，进而确定循环次数

${ }和$( )的区别，${i}是区分其后紧接的字符串，避免“连读”

1. shell中各种括号的作用()、(())、[]、[[]]、{}
1、单小括号 ()
命令组。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
命令替换。等同于`cmd`，$(cmd)
用于初始化数组。如：array=(a b c d)
(ls;ls -a)
c=$(cmd) --> c= cmd result(命令的输出结果)

2. 双小括号 (( ))
整数扩展。这种扩展计算是整数型的计算，不支持浮点型
只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符
单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6
常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。

a=1 b=1
((c=a+b)) --> c=2
c=$((a+b)) --> c=0

3. 单中括号 []
3.1 bash 的内部命令，和test是等同的。
3.2 Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，
整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。
3.3 [ ]中的逻辑与和逻辑或使用-a 和-o 表示。


4. 双中括号[[ ]]
4.1 [[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，
但是会发生参数扩展和命令替换。
4.2 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。
字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。
[[ ]] 中匹配字符串或通配符，不需要引号。
4.3 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。
比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。
比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
4.4 bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

if ($i<5)
if [ $i -lt 5 ]
if [ $a -ne 1 -a $a != 2 ]
if [ $a -ne 1] && [ $a != 2 ]
if [[ $a != 1 && $a != 2 ]]

for i in $(seq 0 4);do echo $i;done
for i in `seq 0 4`;do echo $i;done
for ((i=0;i<5;i++));do echo $i;done
for i in {0..4};do echo $i;done

5. 大括号、花括号 {}
5.1 大括号拓展。将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。
第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt
5.2 几种特殊的替换结构
${var:-string},${var:+string},${var:=string},${var:?string}

${var:-string}和${var:=string}
若变量var为空，则用在命令行中用string来替换${var:-string}，
变量var不为空时，则用变量var的值来替换${var:-string}；
不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var：

${var:+string}
只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。

${var:?string}
若变量var不为空，则用变量var的值来替换${var:?string}；
若变量var为空，则把string输出到标准错误中，并从脚本中退出。
我们可利用此特性来检查是否设置了变量的值。

充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

6. 四种模式匹配替换结构
模式匹配记忆方法：
# 是去掉左边(在键盘上#在$之左边)
% 是去掉右边(在键盘上%在$之右边)
#和%中的单一符号是最小匹配，两个相同符号是最大匹配。
${var%pattern},${var%%pattern},${var#pattern},${var##pattern}

7. 字符串提取和替换
${var:num},${var:num1:num2},${var/pattern/pattern},${var//pattern/pattern}

-------------------------------------
数学运算符

+   加法
-   减法
*   乘法
/   除法
%   取余
=   赋值
==  相等测试，相等则返回true
!=  不相等测试，不相等则返回true

注意： 乘号*前边必须加反斜杠 \ 才能实现乘法运算

关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字
-eq (equal) 检测两个数是否相等，相等则返回 true
-ne (not equal）检测两个数是否相等，不相等则返回 true
-gt (greater than）检测左边的数是否大于右边的，如果是，则返回 true
-lt (lower than) 检测左边的数是否小于右边的，如果是，则返回 true
-ge (greater equal）检测左边的数是否大于等于右边的，如果是，则返回 true
-le (lower equal) 检测左边的数是否小于等于右边的，如果是，则返回 true


布尔运算符
-a  与运算，两个表达式都为 true 才返回 true
-o  或运算，有一个表达式为 true 则返回 true
!   非运算，表达式为 true 则返回 false，否则返回 true

逻辑运算符
&&  逻辑与
II  逻辑或

字符串运算符
=   检测两个字符串是否相等，相等返回 true   [ $a = $b ] 返回 false
!=  检测两个字符串是否相等，不相等返回 true  [ $a != $b ] 返回 true
-z  检测字符串长度是否为0，为0返回 true   [ -z $a ] 返回 false
-n  检测字符串长度是否为0，不为0返回 true  [ -n $a ] 返回 true
str_name    检测字符串是否为空，不为空返回 true    [ $a ] 返回 true


文件测试运算符  (-d 目录， -e 文件+目录，-f 普通文件)
-b file 检测文件是否是块设备文件，如果是，则返回 true
-c file 检测文件是否是字符设备文件，如果是，则返回 true
-g file 检测文件是否设置了 SGID 位，如果是，则返回 true
-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true
-p fill 检测文件是否是命名管道，如果是，则返回 true
-u file 检测文件是否设置了 SUID 位，如果是，则返回 true
-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true

| -d file 检测文件是否是目录，如果是，则返回 true
| -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true
| -e file 检测文件（包括目录）是否存在，如果是，则返回 true
| -r file 检测文件是否可读，如果是，则返回 true
| -w file 检测文件是否可写，如果是，则返回 true
| -x file 检测文件是否可执行，如果是，则返回 true
文件1 -nt 文件2  判断文件1的修改时间是否比文件2新，如果新则为真
文件1 -ot 文件2  判断文件1的修改时间是否比文件2旧，如果旧则为真
文件1 -ef 文件2  判断文件是否为同一个 inode，理解为两个文件是否为同一个文件

---------------------------------------------------
Bash的控制流

条件语句
if [ condition ]
then
    command
fi
--------------------
if [ condition ]
then
    command
else
    command
fi
--------------------
if [ condition1 ]
then
    command1
elif [ condition2 ]
then
    command2
else
    commandN
fi

case语句
case "${var}" in
    "$condition1" )
        command1
    ;;

    "$condition2" )
        command2
    ;;

    * )  # 这里相当于C中case语句的default 
esac

注意：
对变量使用""并不是强制的，因为不会发生单词分离;
每句测试行,都以右小括号)结尾;
每个条件块都以两个分号;;结尾（作用类似C中的break）;
case 块的结束以 esac(case 的反向拼写)结尾.


循环语句


for语句
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
------------------------------------
for (( EXP1; EXP2; EXP3 ))
do
    command1
    command2
    command3
done
注意:  (())中对变量的引用可以不加$


while语句
while [ condition ]
do
    command
done
------------------------
while (( condition ))
do
    command
done
注意:  (())中对变量的引用同样可以不加$

======================================================
Bash的传参机制
$0 是该脚本文件的名字
$1 是第一个参数, $2 是第 2 个参数...
$9 以后就需要大括号了,如 ${10}, ${11}, ${12}...

$#  传递到脚本的参数个数
$*  以一个单字符串显示所有向脚本传递的参数。
$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。
$$  脚本运行的当前进程ID号
$!  后台运行的最后一个进程的ID号
$-  显示Shell使用的当前选项，与set命令功能相同
$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

$* 与 $@ 区别:
相同点：都表示引用所有的位置参数;
不同点：只有在双引号中体现出来。
假设在脚本运行时写了三个参数 1、2、3，，
则 " * " 等价于 "1 2 3"（传递了一个参数），
而 "@" 等价于 "1" "2" "3"（传递了三个参数）。


======================================================
Bash函数

函数的定义

function func_name()
{
    # 函数体
}
注意：
关键字function是可选的;
函数定义必须在第一次调用前完成，shell没有像 C 中的函数“声明”;
在一个函数内嵌套另一个函数也是可以的，但是不常用.

函数的参数传递
函数以位置来引用传递过来的参数(就好像他们是位置参数一样), 例如$1, $2, ...

函数的调用
函数被调用或被触发, 只需要简单地用函数名来调用，有参数的话将参数依次置于函数名之后。


----------------------------------
无参函数的调用
function func1()
{
    echo "Hello World!"
    echo "This is func1"
}

# Calling func1
func1
----------------------------------
有参函数的调用
function func2()
{
    echo "This is func2"
    
    a=$1
    b=$2
    echo "a is : $a"
    echo "b is : $b"
}

# Calling func2,and pass two parameters
func2 "aaa" "bbb"