Beth    4.00    0
Dan    3.75    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18

----------------------------
工作时间超过零小时的员工的姓名和工资（薪资乘以时间）
awk '$3 >0 { print $1, $2 * $3 }' emp.data

没工作过的员工的姓名
awk '$3 == 0 { print $1 }' emp.data

----------------------------
AWK程序的结构
awk程序都是一个或多个模式-动作语句的序列：
pattern { action }
pattern { action }

模式与动作的典型示例,是单个模式-动作语句
$3 == 0 { print $1 }

awk的基本操作是一行一行地扫描输入，搜索匹配任意程序中模式的行
模式和动作两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式

---------------------------
awk 中仅仅只有两种数据类型: 数值 和 字符构成的字符串
Awk 程序一次从输入文件的中读取一行内容并把它分割成一个个字段, 通常默认情况下,
一个字段是一个不包含任何空格或制表符的连续字符序列.
当前输入的行中的地一个字段被称做 $1, 第二个是 $2, 以此类推. 整个行的内容被定义为 $0.
每一行的字段数量可以不同.

 print 语句中被逗号分割的表达式, 在默认情况下他们将会用一个空格分割来输出.
 每一行 print 生成的内容都会以一个换行符作为结束. 但这些默认行为都可以自定义;
 我们将在第二章中介绍具体的方法.

1. NF, 字段数量
当前行的字段数量存 储在一个内建的称作 NF 的变量中
{ print NF, $1, $NF }

2. 打印行号
内建变量 NR, 它会存储当前已经读取了多少行的计数
{ print NR, $0 }

3. 在输出中添加内容
{ print "total pay for", $1, "is", $2 * $3 }

4. 高级输出
print 语句可用于快速而简单的输出。若要严格按照你所想的格式化输出，则需要使用 printf 语句

字段排队
printf 语句的形式如下:
printf(format, value1, value2, ..., valuen)
其中 format 是字符串，穿插着 format 之后的每个值该如何打印的规格(specification)。
一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。

{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) }
 %s     字符串
 %.2f   数字 (*.00)
\n      换行
printf 不会自动产生空格或者新的行，必须是你自己来创建，所以不要忘了 \n 。

5. 模式组合
可以使用括号和逻辑操作符与 && ， 或 || ， 以及非 ! 对模式进行组合
$2 >= 4 || $3 >= 20
!($2 < 4 && $3 < 20)

6. AWK进行计算
注意：一个动作就是一个以新行或者分号分隔的语句序列
创建自己的变量用于计算、存储数据诸如此类的操作。awk中，用户创建的变量不需要声明
$3 > 15 { emp = emp + 1 } END { print emp, "employees worked more than 15 hours" }

{ pay = pay + $2 * $3 } END { print NR, "employees"; print "total pay is", pay; print "average pay is", pay/NR }

{ pay = pay + $2 * $3 }
END { print NR, "employees"
      print "total pay is", pay
      print "average pay is", pay/NR
    }

--------------------------------------------
模式摘要

1. BEGIN { 语句 }
在读取任何输入前执行一次 语句
2. END { 语句 }
读取所有输入之后执行一次 语句
3. 表达式 { 语句 }
对于 表达式 为真（即，非零或非空）的行，执行 语句
4. /正则表达式/ { 语句 }
如果输入行包含字符串与 正则表达式 相匹配，则执行 语句
5. 组合模式 { 语句 }
一个 组合模式 通过与（&&），或（||），非（|），以及括弧来组合多个表达式；
对于组合模式为真的每个输入行，执行语句
6. 模式1，模式2 { 语句 }
范围模式(range pattern)匹配从与 模式1 相匹配的行到与 模式2 相匹配的行（包含该行）之间的所有行，
对于这些输入行，执行 语句 。
BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。
BEGIN和END是仅有的必须搭配动作的模式。

---------------------------------------------
特殊要点:

$0      表示整个当前行
$1      每行第一个字段
NF      字段数量变量
NR      每行的记录号，多文件记录递增
FNR     与NR类似，不过多文件记录不递增，每个文件都从1开始
\t      制表符
\n      换行符

FS      BEGIN时定义分隔符
RS      输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
~       匹配，与==相比不是精确比较
!~      不匹配，不精确比较
==      等于，必须全部相等，精确比较
!=      不等于，精确比较
&&　    逻辑与
||      逻辑或
+       匹配时表示1个或1个以上
/[0-9][0-9]+/   两个或两个以上数字
/[0-9][0-9]*/    一个或一个以上数字
FILENAME 文件名
OFS      输出字段分隔符， 默认也是空格，可以改为制表符等
ORS      输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
-F'[:#/]'   定义三个分隔符

awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd  //输出字段1,3,6，以制表符作为分隔符

BEGIN{FS=":"}

awk '/mysql/' /etc/passwd
awk '/mysql/{print }' /etc/passwd
awk '/mysql/{print $0}' /etc/passwd                   //三条指令结果一样

awk '!/mysql/{print $0}' /etc/passwd                  //输出不匹配mysql的行
awk 'BEGIN { FS=":"} /mail/,/ssh/{print $1}' passwd     区间匹配，mail到ssh
awk 'BEGIN { FS=":"} /mail|ssh/{print $1}' passwd       或匹配，匹配mail或ssh开头
awk 'BEGIN { FS=":"}  $1~/mail|ssh/{print $1}' passwd   字段匹配
awk -F: '$1!~/mail/{print $1}' /etc/passwd          //不匹配


--------------------------------------
IF语句，必须用在{}中，且比较内容用()扩起来
awk 'BEGIN { FS=":" } { if ( $1 == "ssh" ) { print $1 } else if ($1 == "mail")  { print $3 } else { print $2 }}' passwd


输出分隔符OFS
awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt

输出处理结果到文件
①在命令代码块中直接输出    route -n|awk 'NR!=1{print > "./fs"}'
②使用重定向进行输出           route -n|awk 'NR!=1{print}'  > ./fs

NF         字段数量变量
NR         每行的记录号，多文件记录递增
FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始
FS         BEGIN时定义分隔符
RS         输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
OFS        输出字段分隔符， 默认也是空格，可以改为制表符等
ORS        输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕