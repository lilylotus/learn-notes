 1. 正则表达式的文法分为3种标准：
BRE
ERE 
ARE
其中 BER 和 ERE 属于 POSIX 标准，ARE 则是由各家定义的扩展。

 2. POSIX 正则表达式

2.1 BRE 定义的语法符号包括
.       - 匹配任意一个字符。
[]      - 字符集匹配，匹配方括号中定义的字符集之一。
[^]     - 字符集否定匹配，匹配没有在方括号中定义的字符。
^       - 匹配开始位置。
$       - 匹配结束位置。
\(\)    - 定义子表达式。
\n      - 子表达式向前引用，n 为 1-9 之间的数字。 
        由于此功能已超出正则语义，需要在字符串中回溯，因此需要使用 NFA 算法进行匹配。
*       - 任意次匹配（零次或多次匹配）。
\{m,n\} - 至少 m 次，至多 n 次匹配；\{m\} 表示 m 次精确匹配；\{m,\} 表示至少 m
        次匹配。

2.2 ERE 修改了 BRE 中的部分语法，并增加了以下语法符号：
?       - 最多一次匹配（零次或一次匹配）。
+       - 至少一次匹配（一次或更多次匹配）。
|       - 或运算，其左右操作数均可以为一个子表达式。

POSIX 类        perl类     描述
----------------------------------------------------------------------------
[:alnum:]                  字母和数字
[:alpha:]       \a         字母
[:lower:]       \l         小写字母
[:upper:]       \u         大写字母
[:blank:]                  空白字符（空格和制表符）
[:space:]       \s         所有空格符（比[:blank:]包含的范围广）
[:cntrl:]                  不可打印的控制字符（退格、删除、警铃...）
[:digit:]       \d         十进制数字
[:xdigit:]      \x         十六进制数字
[:graph:]                  可打印的非空白字符
[:print:]       \p         可打印字符
[:punct:]                  标点符号

perl类    等效POSIX表达式   描述
-----------------------------------------
\o        [0-7]             八进制数字
\O        [^0-7]            非八进制数字
\w        [[:alnum:]_]      单词构成字符
\W        [^[:alnum:]_]     非单词构成字符
\A        [^[:alpha:]]      非字母
\L        [^[:lower:]]      非小写字母
\U        [^[:upper:]]      非大写字母
\S   [^[:space:]]      非空格符
\D        [^[:digit:]]      非数字
\X        [^[:xdigit:]]     非十六进制数字
\P        [^[:print:]]      非可打印字符

\r  -  回车
\n  -  换行
    -  退格
\t  -  制表符
\v  -  垂直制表符
\"  -  双引号
\'  -  单引号
======================================================================

======================================================================
1. 支持"懒惰匹配"（也叫"非贪婪匹配"或"最短匹配"）：在 '?', '*', '+' 或 '{m,n}'
     后追加 '?' 符号就可以启用最短匹配，使得该正则表达式子句在满足条件的前提下匹
     配尽可能少的字符（默认是匹配尽可能多的字符）。例如：将 "a.*b" 作用于 "abab"
     时，将匹配整个串（"abab"），若使用 "a.*?b"，则将只匹配前两个字符（"ab"）。

2. 支持子表达式的向前引用匹配：在 stRegEx 中，可以使用 '\n' 向前引用曾经定义的
 子表达式。如："(a.*)\1" 可匹配 "abcabc" 等。

3. 无名子表达式：使用 "(?:表达式)" 的方式创建一个无名表达式， 无名表达式不返回
 到一个 '\n' 匹配。

4. 向前预判：要命中匹配，必须向前满足指定条件。 向前预判分为肯定预判和否定预判
 两种。肯定预判的语法为："(?=表达式)"，例如："bai.*(?=yang)" 匹配 "bai yang"
 中的前四个字符（"bai "），但在匹配时保证字符串在 "bai.*" 后必须包含 "yang".
 否定判断的语法为："(?!表达式)"， 例如："bai.*(?!yang)" 匹配 "bai shan" 的前
 四个字符，但在匹配是保证字符串在 "bai.*" 后不出现 "yang"。

5. 支持模式切换前缀，在 "***:" 之后可以紧跟形如 "(?模式串)" 样式的模式串，模式
 串影响其后表达式的语义和行为。模式串可以是一下字符的组合：

 b - 切换至 POSIX BRE 模式，覆盖 bExtended 选项。
 e - 切换至 POSIX ERE 模式，覆盖 bExtended 选项。
 q - 切换至文本字面匹配模式， 表达式中的字符都作为文本进行搜索，取消一切正则
     语义。此模式将正则匹配退化为一次简单字符串查找。"***=" 前缀是其快捷表示
     方式，意即："***=" 等同于 "***:(?q)"。

 c - 执行大小写敏感的匹配，覆盖 bNoCase 选项。
 i - 执行忽略大小写的匹配，覆盖 bNoCase 选项。

 n - 开启行敏感的匹配：'^' 和 '$' 匹配行首和行尾；'.' 和否定集（'[^...]'）不
     匹配换行符。此功能等同于 'pw' 模式串。覆盖 bNewLine 选项。
 m - 等同于 'n'。
 p - '^' 和 '$' 只匹配整个字符串的首尾，不匹配行；'.' 和否定集不匹配换行符。
     覆盖 bNewLine 选项。
 w - '^' 和 '$' 匹配行首和行尾；'.' 和否定集匹配换行符。覆盖 bNewLine 选项。
 s - '^' 和 '$' 只匹配整个字符串的首尾，不匹配行；'.' 和否定集匹配换行符。覆
     盖 bNewLine 选项。ARE 状态下默认使用此模式。

 x - 开启扩展模式：在扩展模式中，将忽略表达式中的空白符和注释符 '#' 后的内容
     例如：
     @code@
        (?x)
        \s+ ([[:graph:]]+)      # first number
        \s+ ([[:graph:]]+)      # second number
     @code@
     等同于 "\s+([[:graph:]]+)\s+([[:graph:]]+)"。
 t - 关闭扩展模式，不忽略空白符和注释符后的内容。ARE 状态下默认使用此模式。

6. 与 BRE/ERE 模式不同的 Perl 风格字符类换码序列：

perl类    等效POSIX表达式   描述
----------------------------------------------------------------------------
\a        -                 响铃字符
\A        -                 不论当前模式如何，仅匹配整个串的最开头
        -                 退格字符 ('\x08')
\B        -                 转义字符本身 ('\\')
\cX       -                 控制符-X (= X & 037)
\d        [[:digit:]]       10 进制数字 ('0' - '9')
\D        [^[:digit:]]      非数字
\e        -                 退出符 ('\x1B')
\f        -                 换页符 ('\x0C')
\m        [[:<:]]           单词开始位置
\M        [[:>:]]           单词结束位置
\n        -                 换行符 ('\x0A')
\r        -                 回车符 ('\x0D')
\s        [[:space:]]       空白符
\S        [^[:space:]]      非空白符
\t        -                 制表符 ('\x09')
\uX       -                 16 位 UNICODE 字符 (X∈[0000 .. FFFF])
\UX       -                 32 位 UNICODE 字符 (X∈[00000000 .. FFFFFFFF])
\v        -                 纵向制表符 ('\x0B')
\w        [[:alnum:]_]      组成单词的字符
\W        [^[:alnum:]_]     非单词字符
\xX       -                 8 位字符 (X∈[00 .. FF])
\y        -                 单词边界（\m 或 \M）
\Y        -                 非单词边界
\Z        -                 不论当前模式如何，仅匹配整个串的最尾部
\0        -                 NULL，空字符
\X        -                 子表达式向前引用 (X∈[1 .. 9])
\XX       -                 子表达式向前引用或 8 进制表示的 8 字符
\XXX      -                 子表达式向前引用或 8 进制表示的 8 字符

======================================================================

======================================================================
\   将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
^   匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
$   匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
*   匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+   匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?   匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
{n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}    n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}   m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
?   当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
.   匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
(pattern)   匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
x|y 匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
[xyz]   字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^xyz]  负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。
[a-z]   字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[^a-z]  负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B  匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\d  匹配一个数字字符。等价于 [0-9]。
\D  匹配一个非数字字符。等价于 [^0-9]。
\f  匹配一个换页符。等价于 \x0c 和 \cL。
\n  匹配一个换行符。等价于 \x0a 和 \cJ。
\r  匹配一个回车符。等价于 \x0d 和 \cM。
\s  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t  匹配一个制表符。等价于 \x09 和 \cI。
\v  匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w  匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W  匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。.
\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n  标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (©)。
======================================================================

======================================================================
1. 
//校验是否全由数字组成
/^[0-9]{1,20}$/
/^ 和 $/成对使用应该是表示要求整个字符串完全匹配定义的规则，而不是只匹配字符串中的一个子串。
2.
//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/
3. 
//校验用户姓名：只能输入1-30个以字母开头的字串
/^[a-zA-Z]{1,30}$/
4.
//校验密码：只能输入6-20个字母、数字、下划线
/^(\w){6,20}$/
\w：用于匹配字母，数字或下划线字符
5.
//校验普通电话、传真号码：可以“+”或数字开头，可含有“-” 和 “ ”
/^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/
\d：用于匹配从0到9的数字；
“?”元字符规定其前导对象必须在目标对象中连续出现零次或一次
6.
//校验URL
/^http[s]{0,1}:\/\/.+$/ 或 /^http[s]{0,1}:\/\/.{1,n}$/ (表示url串的长度为length(“https://”) + n )
\ / ：表示字符“/”。
. 表示所有字符的集
+ 等同于{1,}，就是1到正无穷吧。

7. 
//校验纯中文字符
/^[\u4E00-\u9FA5]+$/
 
[\u4E00-\u9FA5] ：估计是中文字符集的范围吧
======================================================================

======================================================================
"^\d+$"　　//非负整数（正整数 + 0） 
"^[0-9]*[1-9][0-9]*$"　　//正整数 
"^((-\d+)|(0+))$"　　//非正整数（负整数 + 0） 
"^-[0-9]*[1-9][0-9]*$"　　//负整数 
"^-?\d+$"　　　　//整数 
"^\d+(\.\d+)?$"　　//非负浮点数（正浮点数 + 0） 
"^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数 
"^((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　//非正浮点数（负浮点数 + 0） 
"^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数 
"^(-?\d+)(\.\d+)?$"　　//浮点数 
"^[A-Za-z]+$"　　//由26个英文字母组成的字符串 
"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串 
"^[a-z]+$"　　//由26个英文字母的小写组成的字符串 
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串 
"^\w+$"　　//由数字、26个英文字母或者下划线组成的字符串 
"^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　//email地址 
"^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　//url
/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/   //  年-月-日
/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/   // 月/日/年
"^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$"   //Emil
"(d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?"     //电话号码
"^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$"   //IP地址
^([0-9A-F]{2})(-[0-9A-F]{2}){5}$   //MAC地址的正则表达式
^[-+]?\d+(\.\d+)?$  //值类型正则表达式
======================================================================

======================================================================
1. javascript正则表达式检验
var patrn=/^[0-9]{1,20}$/;
if (!patrn.exec(s)) return false;
return true;

//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;
if (!patrn.exec(s)) return false
return true


"^\\d+$"　　//非负整数（正整数 + 0） 
"^[0-9]*[1-9][0-9]*$"　　//正整数 
"^((-\\d+)|(0+))$"　　//非正整数（负整数 + 0） 
"^-[0-9]*[1-9][0-9]*$"　　//负整数 
"^-?\\d+$"　　　　//整数 
"^\\d+(\\.\\d+)?$"　　//非负浮点数（正浮点数 + 0） 
"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数 
"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"　　//非正浮点数（负浮点数 + 0） 
"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数 
"^(-?\\d+)(\\.\\d+)?$"　　//浮点数 
"^[A-Za-z]+$"　　//由26个英文字母组成的字符串 
"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串 
"^[a-z]+$"　　//由26个英文字母的小写组成的字符串 
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串 
"^\\w+$"　　//由数字、26个英文字母或者下划线组成的字符串 
"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"　　　　//email地址 
"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"　　//url
=======================================================================

======================================================================
1.JAVA正则表达式语法示例
匹配验证-验证Email是否正确

// 要验证的字符串
String str = "service@xsoftlab.net";
// 邮箱验证规则
String regEx = "[a-zA-Z_]{1,}[0-9]{0,}@(([a-zA-z0-9]-*){1,}\\.){1,3}[a-zA-z\\-]{1,}";
// 编译正则表达式
Pattern pattern = Pattern.compile(regEx);
// 忽略大小写的写法
// Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
Matcher matcher = pattern.matcher(str);
// 字符串是否与正则表达式相匹配
boolean rs = matcher.matches();
System.out.println(rs);
======================================================================