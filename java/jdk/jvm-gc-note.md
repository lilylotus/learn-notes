### JVM GC 笔记

```bash
–XX:+UseSerialGC
–XX:+UseParallelGC # 默认开启压缩
–XX:+UseParallelOldGC # 关闭压缩
–XX:+UseConcMarkSweepGC
-XX:+UseG1GC

# GC 信息
–XX:+PrintGCDetails

```

#### 1. 并行 GC (Parallel Collector)

并行 *GC*  又被称为 *throughput collector* 吞吐量垃圾收集器

##### 1.1 使用并行收集器收集 *Young Generation*

并行收集器使用串行收集器使用的年轻一代收集算法的并行版本。
仍是一个 *STW* 的复制收集器，用许多 CPU 并行执行年轻代收集，减少垃圾收集开销，提高应用程序吞吐量

![parallel gc](../../images/parallel-gc.png)

##### 1.2 使用并行收集器收集 *Old Generation*

使用与串行收集器相同的串行 mark-sweepcompact 收集算法来完成并行收集器的 *Old Generation* 圾收集

##### 1.3 使用命令参数

```bash
java -XX:+UseParallelGC -jar xxx.jar
```

##### 1.4 压缩对象

1. 每个代都被划分在固定大小的区域内
2. 标记阶段
   初始化从代码可以直接获取的对象分发到多个线程中各自标记 live 对象，致使所有的 live 对象都被并发标记线程标记完成。该区域的数据被更新信息关于对象的大小和位置。
3. 汇总阶段
   操作的是区域不是对象。

#### 2. 并发标记清除收集器 (Concurrent Mark-Sweep (CMS) )

*Young generation* 收集通常不会导致很长的暂停。 *old generation* 尽管不频繁，可以导致很长的暂停，尤其是当 *heaps* 很大的时候。

*low-latency* collector [低延迟收集器]

CMS收集器以与并行收集器相同的方式收集年轻代。

使用CMS收集器收集的大多数 *old generation* 是在执行应用程序的同时完成的。
*CMS* 的收集周期开始于一个短暂的暂停
*initial mark* (初始化标记)：该暂停标识了可直接从应用程序代码访问的活动对象的初始集合。
*concurrent marking phase* 并发标记阶段：标记从初始化标记 live 对象集合中传递可达的对象。由于在标记阶段进行期间，应用程序正在运行并更新参考字段，不能保证所有的 live 对象在该阶段最后都被标记完成。为了处理这个问题，在第二阶段应用程序暂停来重新标记，称为 *remark*，通过重新访问在并发标记阶段修改的任何对象来最终确定标记。因为  *remark* 暂停比初始标记更重要，所以并行运行多个线程以提高其效率。在 *remark* 阶段结束后，所有的 *live* 对象在 *heap* 中的都被保证会被标记，于是随后的并发扫除阶段回收所有已经被鉴定的垃圾。

![cms](../../images/cms-gc.png)

*CMS* 是唯一一个没有压缩功能的收集器。
![cms no compact](../../images/cms-no-compacting.png)

**缺点：**

*CMS* 节约了时间，但是空闲的空间不在连续，收集器不能再使用简单的指针来指示可以将下一个对象分配到的下一个空闲位置。 相反它现在需要使用空闲列表。
也就是说，它创建了一些将未分配的内存区域链接在一起的列表，并且每次需要分配对象时，都必须在适当的列表（基于所需的内存量）中搜索足以容纳该对象的区域。 结果，与使用简单的“触手可及”技术相比，分配给旧一代的开销更大。 这也给年轻一代集合增加了额外的开销，因为在年轻一代集合中提升对象时，旧一代中的大多数分配都会发生。
另一个 *CMS* 缺点就是它需要比其它收集器更大的堆空间。如果允许该应用程序在标记阶段运行，则它可以继续分配内存，从而有可能继续增长旧的一代。
此外，尽管收集器保证在标记阶段识别所有活动对象，但是某些对象可能在该阶段成为垃圾，并且直到下一个旧的收集阶段才将它们回收。 这些对象称为浮动垃圾。
由于在缺乏内存压缩将会导致可能出现分段。为了处理碎片，CMS 收集器跟踪常用的对象大小，估计未来的需求，并可能拆分或合并空闲块以满足需求。

与其它收集器不同的是，当 *Old Generation* 变满后 *old Generation* 收集器不会启动收集垃圾。相反，它会尝试提前开始收集那么可以在 *old Generation* 满发生之前完成收集。否则，CMS收集器将恢复为并行和串行收集器使用的更耗时的“停止运行”标志压缩紧凑算法。

使用参数

```bash
java -XX:+UseConcMarkSweepGC -jar xxx.jar
```



总而言之，与并行收集器相比，CMS收集器有时会显着减少旧一代的停顿，但代价是年轻一代的停顿时间会稍长一些，吞吐量会有所降低，并且需要额外的堆大小。

#### 3. G1 垃圾收集 (Garbage-First - G1)

G1收集器通过多种技术实现了高性能和暂停时间目标。

堆被划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围。
G1 执行并发全局标记阶段，以确定整个堆中对象的活动性。
标记阶段完成后，G1知道哪些区域大部分为空。它首先收集这些区

域，这通常会产生大量的自由空间。
这就是为什么这种垃圾收集方法称为“垃圾优先”的原因。
顾名思义，G1 将其收集和压缩活动集中在可能充满可回收对象（即垃圾）的堆区域。
G1 使用暂停预测模型满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。

G1将对象从堆的一个或多个区域复制到堆上的单个区域，并在此过程中压缩并释放内存。
疏散是在多处理器上并行执行的，以减少暂停时间并增加吞吐量。
因此，对于每个垃圾回收，G1 都会不断减少碎片。这超出了先前两种方法的能力。
<font color="blue">CMS（并发标记扫描）垃圾收集不会进行压缩。并行压缩仅执行整堆压缩，这会导致相当长的暂停时间。</font>

G1 的首要重点是为运行需要大堆且 GC 延迟有限的应用程序的用户提供解决方案。
这意味着堆大小约为 6 GB 或更大，并且稳定且可预测的暂停时间低于0.5秒。