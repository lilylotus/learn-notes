##### 运行方式

以 *client* 模式 `-client`

> **Java HotSpot Client VM** (*client VM*)
> 客户端 VM 已进行调整，以减少启动时间和内存占用。

以 *server* 模式 `-server`

> **Java HotSpot Server VM** (*server VM*)
> 服务器虚拟机旨在最大程度地提高程序执行速度



##### 简介

> garbage collector (GC) 内存管理工具
> 将对象分配给年轻一代 (young generation)，并将老化的对象提升为老一代 (old generation)。
> <font color="red">并发 (concurrent) ，并行 (parallel) </font>
> <font color="blue">Concurrent Mark Sweep (CMS) Collector/Garbage-First Garbege Collector (G1)/Parallel Collector</font>

> Serial Collector 通常足够使用对于小的应用 (需要高达 100MB 的 Heap 内存，在现代的处理器上)
> 如果应用程序不需要备用收集器的特殊行为，请使用串行收集器 (Serial Collector)
>
> 大型、多线程应用程序运行在具有大量内存和两个或多个处理器的计算机上 不适用 串行收集器
> 在此类服务器级计算机上运行应用程序时，默认情况下会选择并行收集器。

##### 垃圾收集器，堆和运行时编译器的默认选择

> 服务器类型的机器定义：两个及其以上的物理处理器，2GB 及其以上的物理内存
> 默认行为：
> 	吞吐量的垃圾收集器。
> 	初始化 Heap 大小为 1/64 物理内存，最大到 1GB。
> 	最大 Heap 大小为 1/4 物理内存，最大为 1GB。
> 	Server 运行时的编译器

```java
最大暂停时间目标: (自动调整 Heap 和其它参数，使垃圾收集时间小于 nnn 毫秒)
-XX:MaxGCPauseMillis=<nnn> (milliseconds 毫秒)

吞吐量目标：
-XX:GCTimeRatio=<nnn> (垃圾收集时间与应用程序时间之比 1/(1+nnn))
垃圾收集时间为 年轻代和老年代 的和
```

###### 基于行为的调整

> 对于并行收集器，*Java SE* 提供了两个垃圾收集器调整参数。最大暂停时间 (*maximum pause time*) 目标和应用程序吞吐量 (*throughput*) 目标。这两个选项在其他收集器中不可用。请注意，这些行为不能总是得到满足。
> `-XX:MaxGCPauseMillis=<nnn>` 最大响应时间
> `-XX:GCTimeRatio=19` 吞吐量

调整策略

> 不要选择最大的 Heap 大小，除非知道需要的 heap 大小大于默认的 heap 大小。
> 选择一个吞吐量的指标已经足够应用程序使用
>
> 串行垃圾收集器是为具有小型数据集的应用程序设计的，其默认参数被选择为对大多数小型应用程序有效。
> 并行或吞吐量垃圾收集器旨在与具有中大型数据集的应用程序一起使用。
>
> 吞吐量是长时间内未用于垃圾回收的总时间的百分比。
> 暂停是指由于正在进行垃圾回收而导致应用程序无响应的时间。



`-verbose:gc` 使有关堆和垃圾收集的信息在每个收集处打印

`-XX:+PrintGCDetails `使有关垃圾收集的其他信息被打印

```java
[GC (Allocation Failure) [PSYoungGen: 130663K->2368K(152576K)] 130663K->2384K(500736K), 0.0052368 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

PSYoungGen -> 表示 YoungGen 区的
[130663K->2368K] -> (垃圾回收前的活动对象大小 | 垃圾回收后的活动对象大小)
(152576K) -> Java 对象可使用的空间，而无需从操作系统获取空间, 注意：这仅是包含一个 [survivor spaces]
130663K->2384K(500736K) -> YoungGen 区大小从 130663K 到 2384K，总大小为 500736K
0.0052368 secs -> 垃圾回收所用的时间
```

```java
5.617（时间戳）: 
[GC（Young GC） 5.617（时间戳）: 
[ParNew（GC的区域）: 
43296K（垃圾回收前的大小）->7006K（垃圾回收以后的大小）(47808K)（该区域总大小）, 
0.0136826 secs（回收时间）] 
44992K（堆区垃圾回收前的大小）->8702K（堆区垃圾回收后的大小）(252608K)（堆区总大小）,
 0.0137904 secs（回收时间）] 
[Times: user=0.03（GC用户耗时） sys=0.00（GC系统耗时）, real=0.02 secs（GC实际耗时）]
```

`-XX:+PrintGCTimeStamps ` 在每个垃圾收集的开始添加一个时间戳

> `[DefNew`, `[Tenured`, `[Perm` 表示 GC 发生的区域，区域的名称与使用的 GC 收集器相关。
> *Serial* 收集器中新生代名为 *Default New Generation*，显示的名字为 `[DefNew`。
> *ParNew* 收集器，显示的是 `[ParNew`，表示 *Parallel New Generation*。 
> *Parallel Scavenge* 收集器，新生代名为 `[PSYoungGen`。

> `young` 区域就是新生代，存放新创建对象；
> `tenured` 是年老代，存放在新生代经历多次垃圾回收后仍存活的对象；
> `perm` 是永生代，存放类定义信息、元数据等信息。

```java
-XX:+PrintGCDetails
-XX:+PrintHeapAtGC
-XX:+PrintGCDateStamps
-XX:+PrintTenuringDistribution
-verbose:gc
-Xloggc:gc.log
```

##### 调整世代区块大小

> 影响垃圾收集性能的最重要因素是总可用内存。
> 由于收集是在 Generations 填满时发生的，因此吞吐量与可用内存量成反比。

参数调整：整个堆绑定最小 `-Xms<min>` 最大 `-Xmx<max>`， 固定年轻代的大小

> 影响垃圾收集性能的第二大影响因素是专用于年轻一代的堆的比例。
> 年轻一代越大，垃圾收集的次数就越少。但是在固定的堆大小情况下，较大的年青代意味着较小的 (tenured)老年代，增加 (major collections) 的频度。
> 最佳选择取决于应用程序分配的对象的生命周期分布。

参数：`-XX:NewRatio=3` 年轻代大小控制
表示年轻代和老年代的占比为 1:3 ，所以 *eden* 和 *survivor* 区域占总 Heap 的 1/4

参数：`-XX:SurvivorRatio=6` 配置 Survivor 区域的大小
表示 *eden*  和一个 *survivor* 空间的比值 1:6 ，也就是两个 survivor 区域大小为年轻代的 1/8
**注意：** 如果 *survivor* 区域太小，复制收集的时候溢出会直接到老年代空间中。太大则都空的没有用处

`-XX:+PrintTenuringDistribution` 打印 *survivor* 的阈值和对象在新一个代区域的年龄大小。

> 在分配个年轻代足够的空间前提下，保证老年代足够大可以保存整个应用数据所需要的空间，使老年代有一定的闲着空间，在 (10 - 20% 或者更多)
>
> 随着处理器数量的增加，可以增加年轻代的大小，因为分配可以并行化。
> 分配大量的内存给年轻代。



##### 垃圾收集器

`Java HotSpot VM` 包含了三中不同功能的垃圾收集器

1. 串行收集器`(serial collector)`  (`-XX:+UseSerialGC`)
   使用单一的一个线程处理所有的垃圾收集工作。因为没有线程间的通信，使得效率相对高效。*最适合单个物理线程的机器*

2. 并行收集器 `(parallel collector)`/ 吞吐量收集器 `(throughput collector)` 
   `[-XX:+UseParallelGC]` (默认开启并行压缩) /`[-XX:-UseParallelOldGC]` (关闭并行压缩)
   并行执行次要的收集，显著降低垃圾收集的开销。
   并行压缩有一个功能默认允许在执行 *major collections* 的时候也采用并行收集，(默认开启)
   没有并行压缩，*major collections* 执行使用单线程，明显限制了可扩展性。

   [中大型数据集的应用程序]
   
3. 并发收集器 `Concurrent Collector`  [中大型数据集应用程序] [响应时间比吞吐量更重要]
   `-XX:+UseConcMarkSweepGC` / `-XX:+UseG1GC`

   大多数并发的收集器会同时执行其大部分工作（例如，在应用程序仍在运行时），以使垃圾收集暂停时间较短。
   用于最小化暂停的技术可能会降低应用程序性能
   两个最出名的并发垃圾收集器：

   - 并发标记扫描（CMS）收集器 `Concurrent Mark Sweep (CMS) Collector`
     该收集器用于那些希望更短的垃圾收集暂停并能够与垃圾收集共享处理器资源的应用程序
   - 第一垃圾收集器 `Garbage-First Garbage Collector`
     此服务器样式的收集器用于具有大内存的多处理器计算机。
     它在实现高吞吐量的同时极有可能满足垃圾收集暂停时间目标。

###### 垃圾收集器选择策略

> 让 VM 自己选择收集器，可通过调整堆的大小优化性能。
>
> 1. 如果应用有小的数据集 (大概在 100 MB)，选择串行收集器。 `-XX:+UseSerialGC`
> 2. 如果应用运行在单个物理处理器的机器上并没有停顿时间要求，让 VM 自行选择或者串行收集器 
>    `-XX:+UseSerialGC`
> 3. 如果 (a) 高性能应用优先第一要务 (b) 没有暂停时间要求，也可以接受1秒或更长的暂停时间，可让 VM 自行选择，或使用 并行垃圾收集器 (parallel collector) `-XX:+UseParallelGC`
> 4. 如果响应时间比吞吐量更加重要，并且暂停时间必须保持在大概 1 秒以下，选择并发垃圾收集器
>    `-XX:+UseConcMarkSweepGC` 或者 `-XX:+UseG1GC`

以上的几点仅是垃圾收集器选择的基本点，因为性能依靠于 Heap 大大小，应用维护实时活动数据的数量，可用处理器的数量和速度。暂停时间对这些因素特别敏感，前面提到的 1 秒阈值仅是近似值，在许多数据大小和硬件组合上，并行收集器 (parallel collector) 的暂停时间将超过1秒，相反的，并发收集器 (concurrent collector) 在某些组合上可能无法使暂停时间短于1秒。
如果推荐的收集器未达到所需的性能，请首先尝试调整 *heap* 和 *generation*大小以满足所需的目标，如果还是达不到目标，尝试不同的垃圾收集器，使用 *concurrent collector* 收集器减少暂停时间和使用 *parallel collector* 增加总体的吞吐量在多处理器的硬件当中。

<font color="red">Concurrency (并发):  *应用程序如何处理其工作的多个任务*，在同时处理多个任务 [work on multiple tasks at the same time] (同一个 CPU)。可以充分利用 CPU 的性能，达到最高的处理性能，多个线程区抢占 CPU 时间片，CPU 空闲时间会大大减少。</font>
<font color="blue">Parallelism (并行):  *应用程序如何处理每个单独的任务*，同一时刻执行多个任务，如应用程序将其任务分解为较小的子任务，子任务可以并行处理，例如在多个 CPU 上同时进行。</font>

##### 并行收集器 (parallel collector)

> 与串行收集器不同点在于使用的是多个线程来处理加速垃圾收集。 `-XX:+UseParallelGC`
> 默认是 *minor* 和 *major* 收集都使用并行来进一步减少垃圾收集的开销。

> <font color="blue">在硬件线程数 *N* 大于 8 时，垃圾收集器采用固定线程数 (5/8 * N)，若是线程数小于 8，那么使用的就是 N</font>
> 当运行在单处理器的机器上时，性能效果和串行处理器是一样的。当应用程序运行在一般到大型的 Heap 大小时，两个处理器的执行效果一般会比串行垃圾收集要稍好，但是在多于 2 个处理器的机器上通常性能要比串行收集器好得多

`-XX:ParallelGCThreads=<N>` 控制并行处理的线程大小
**注意：** 并行垃圾收集会在年轻代到老年代转移时会提高碎片的产生，可以减少并行处理的线程数量和增加老年代区域的大小降低碎片的产生效果。 
![parallel collector](C:\programming\dailyRecord\images\parallel-collector.png)

默认情况下，在服务器级计算机上选择并行收集器。

1. 最大垃圾回收暂停时间 `-XX:MaxGCPauseMillis=<N>`
   指定垃圾收集的暂停时间 (milliseconds 毫秒)，设置了此参数后垃圾收集器会自动的调整相关的配置参数来满足这个指定的暂停时间，仅会小于或等于 N，但是随着参数的调整会影响到全局的吞吐量，还有就是不是任何时候都能满足这个暂停时间目标可以达到。
2. 吞吐量 (***Throughput***) ``XX:GCTimeRatio=<N>` 设置垃圾收集时间与应用时间的比值 *[1/(N+1)]*
   吞吐量目标是根据进行垃圾收集所花费的时间与在垃圾收集之外所花费的时间（称为应用程序时间）来衡量的
   默认的设置是 99， 表示垃圾收集占用时间为 1/100
3. 空间 (Footprint) `-Xmx`  -> 最大的堆 (Heap) 的空间

<font color="red">目标 (Goals) 的优先级：首先达到最大暂停时间目标。只有在达到目标之后，才能实现吞吐量目标。同样，只有在达到前两个目标后，才会考虑空间目标。</font>

<font color="blue">自动调整 Generation 的大小</font>
统计 *暂停时间* 会在每次收集之后更新，然后在依据此统计信息判定是否达到目标，在对 Generation 进行必要的大小调整。但是显示的垃圾回收 (System.gc()) 会被统计所排除。

暂停时间没有达到会缩小 generation 的大小
吞吐量没有达到会增加两个 generation 的大小

<font color="blue">默认的 Heap 大小</font>

物理内存在 129 MB 时，heap 大小为 1/2， 物理内存大于等于 1 GB 的时候，为 1/4。
除非程序创建了足够多的对象来要请求空间，否则 JVM 实际上并没有使用最大堆大小。

<font color="red">分配给年轻代的最大空间量是总堆大小的三分之一</font>

<font color="orange">如果 `-Xms` 与 `-Xmx` 配置不一样，JVM将首先使用初始堆大小，然后再扩展Java堆，直到在堆使用和性能之间找到平衡为止。</font>

`-XX:+PrintFlagsFinal` 在终端显示 *MaxHeapSize* 

**过多的 GC 时间和 OutOfMemoryError 异常**
并行收集器会抛出 OutOfMemoryError 异常，当太多的时间花费在 *garbage collection (GC)* 上面。
如果超过 *98％* 的总时间花费在垃圾收集上，而回收不到 *2％* 的堆，就会抛出 *OutOfMemoryError*。
此功能旨在防止应用程序长时间运行，而由于堆太小而进展甚微或没有进展。
`-XX:-UseGCOverheadLimit` 类禁止此异常抛出

##### 最主要的并发 (Concurrent) 收集器

- Concurrent Mark Sweep (CMS) Collector [并发标记扫描]
- Garbage-First Garbage Collector [G1 收集器]

最主要的垃圾收集器是以使用处理器资源为代价，缩短 *major collections* 的暂停时间。
可见的开销是在并行收集部分所使用的一个或者多个处理器资源。
对于一个 *N* 处理器的系统，在并行垃圾收集的阶段会使用 *K/N (1<=K<=ceiling(N/4))* 个处理器资源。
因此，虽然并发收集器的垃圾收集暂停通常要短得多，但应用程序吞吐量也往往比其他收集器要低一些。

在有多个处理核心的机器上，在并发垃圾收集的时候处理器线程也可供应用程序使用，所以并发垃圾收集线程不会使应用程序暂停。
通常的结果就是缩短暂停时间，但是可以预见的是会有较少的处理资源被应用程序使用导致处理降低。
随着核心N的增加，由于并发垃圾收集而导致的处理器资源减少将变得更小，并且并发收集的收益也会增加。

##### 并发标记扫描（Concurrent Mark Sweep [CMS]）收集器  `-XX:+UseConcMarkSweepGC`

> 并发标记扫描（CMS）收集器是为那些希望较短的垃圾收集暂停并且可以在应用程序运行时与垃圾收集器共享处理器资源的应用程序设计的。
> 推荐：大量的 *老年代* 和多核心处理器的应用程序。

*CMS* 收集器尝试通过使用单独的垃圾收集器线程在执行应用程序线程的同时并跟踪可访问对象，来减少由于 *major collection* 而导致的暂停时间。
在每个 *major collection* 期间，*CMS* 收集器会在开始的一小段时间暂停所有的应用程序线程，然后收集中间时间段在暂停一段时间。第二个停顿往往是两个停顿中较长的一个。在两个暂停期间都使用多个线程来执行收集工作。
包括大多数对活对象的追踪和清除不可追踪对象是有一个或多个垃圾收集器线程和应用程序并发执行。
*Mirror Collection*  可以和主要周期一起交错执行，类似于并行收集器的方式。
[注意：在 *Mirror Collection* 期间，应用程序线程会停止]

###### 并发模式的失败

*CMS* 收集器使用一个或者多个垃圾收集线程和应用程序线程同时运行，完成在老年代区在填满之前进行垃圾收集的目标。
注意：在 *CMS* 收集器在进行大多数的追踪和清除工作时应用程序线程依然在执行，所以对应用程序来说仅仅时简短的暂停。
但是如果在 *老年代* 区域满之前还没有回收不活动对象或者老年代没有合适的空间分配对象，那么应用程序将会暂停，所有垃圾收集完成之前程序会一直暂停。
无法同时完成收集的情况称为并发模式故障，表示需要调整CMS收集器参数。
如果并发收集被显式垃圾收集（System.gc（））中断，或者为提供诊断工具信息所需的垃圾收集中断了，则将报告并发模式中断。

*CMS* 收集器会抛出 *OutOfMemoryError* 异常，当过多的时间花费在垃圾收集上。超过总时间的 *98%* 都用来垃圾收集或者少于 *2%* 的 heap 空间被回收。这个特性设计来防止 *heap* 太小，防止应用程序长时间几乎没有处理能力。
`-XX:-UseGCOverheadLimit` 添加来禁止此异常抛出。
仅在应用程序线程停止后的收集时间算入过多的 *GC* 时间。 

###### 浮动垃圾

应用程序线程和垃圾收集器线程在 *major collection* 期间同时运行，垃圾收集器线程跟踪的对象随后可能会在收集过程结束时变得不可访问。尚未回收的此类无法访问的对象称为浮动垃圾。
浮动垃圾的数量取决于并发收集周期的持续时间以及应用程序对引用更新（也称为变异）的频率。
因为年轻一代和终身一代是独立收集的，所以彼此起着根源的作用。
作为粗略的指导，尝试将永久代的大小增加 *20％*，以解决浮动垃圾的问题。
在一个并发收集周期结束时，将在下一个收集周期中收集堆中的浮动垃圾。

###### 暂停 (一周期两次)

*CMS* 收集器在并发收集周期当中暂停应用程序两次。
第一次暂停是将可从根 (root) 直接访问的对象标记为活动对象，(例如，来自应用程序线程堆栈和寄存器，静态对象等的对象引用以及来自堆中其他位置（如，年轻一代）的对象引用)
<font color="blue">此第一次暂停称为初始标记暂停 (*initial mark pause*)</font>
第二次暂停是在并发跟踪阶段的末尾，并查找由于 *CMS* 收集器完成对对象的引用后，应用程序线程对对象中的引用进行了更新而导致并发跟踪遗漏的对象。
<font color="blue">该第二暂停称为备注暂停 (*remark pause*)</font>

###### 并发阶段

可达对象图的并发跟踪发生在初始标记暂停和注释暂停之间。在此并发跟踪阶段中，一个或多个并发垃圾收集器线程可能正在使用处理器资源，否则这些资源将可供应用程序使用。
结果，即使没有暂停应用程序线程，在此阶段和其他并发阶段中，受计算绑定的应用程序的应用程序吞吐量也可能会相应下降。
备注 (*remark*) 暂停后，并发清除阶段将收集标识为不可访问的对象。
收集周期完成后，*CMS* 收集器将等待，几乎不消耗任何计算资源，直到下一个主要收集周期开始。

###### 开始并发收集周期

使用串行收集器时，一个 *major collection* 发生在每当*老年代* 变满，然后所有的应用程序线程将停止知道收集完毕。
与之相反，并发收集必须时定时的，以致在 *老年代* 变满之前收集结束，否则由于并发故障，应用程序将观察到更长的暂停。
有几种启动并发收集的方法：
根据最近的历史记录，CMS 收集器将保留对永久性代用尽之前的剩余时间以及并发收集周期所需时间的估计。
使用这些动态估计，开始并发的收集周期目标是在 *tenured generation* 区用尽之前完成收集垃圾任务。
为了安全起见，对这些估计值进行了填充，因为并发模式故障的代价可能很高。

如果终身代的占用率超过初始占用率，也会启动并发收集。(*tenured generation* 区的百分占比)
默认的初始占比阈值是 *92%*，但是该值可能会因版本而异。
``-XX:CMSInitiatingOccupancyFraction=<N>` 调节占比，*N* 是 *tenured generation* 的大小占比 (0-100)

###### 安排暂停

*young generation* 的收集和 *tenured generation* 收集的暂停是独立发生的。
它们不会重叠，但可能会快速连续发生，因此一个集合的暂停，紧接着是另一个集合的暂停，可能看起来像是一个较长的暂停。为了避免这种情况，CMS 收集器尝试安排注释 (*remark*) 暂停在上次和下一个 *young generation* 暂停之间的大致中间时间。
当前尚未为初始标记暂停执行此计划，该时间通常比标记暂停短得多。

<font color="red">请注意，Java SE 8中不推荐使用增量模式 (*Incremental Mode*) ，并且在将来的主要版本中可能会删除它。</font>

<font color="blue">`-XX:+UseConcMarkSweepGC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps`</font>
CMS 收集器的输出已散布在次要收集的输出中
*CMS-initial-mark* 指示并发收集周期的开始
*CMS-concurrent-mark* 指示并发标记阶段的结束
*CMS-concurrent-sweep* 指示并发清除阶段的结束
最终阶段由 *CMS-concurrent-reset* 指示，并且正在准备下一个并发收集。

##### Garbage-First Garbage Collector (G1 收集器)  `-XX:+UseG1GC`

> *G1* 收集器是 *服务器类型* 的垃圾收集器，目标是针对多处理器机器和大量可用内存。
> 它尝试以高概率满足垃圾收集（GC）暂停时间目标，同时实现高吞吐量。
> 全堆操作（例如全局标记）与应用程序线程同时执行。
> 这样可以防止与堆或活动数据大小成比例的中断。

G1 收集器通过多种技术实现了高性能和暂停时间目标。

堆被划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围。
G1 执行并发全局标记阶段，以确定整个堆中对象的活动性。标记阶段完成后，G1 知道哪些区域大部分为空。
它首先收集这些区域，这通常会产生大量的自由空间。
顾名思义，G1 将其收集和压缩活动集中在可能充满可回收对象（即垃圾）的堆区域中。
G1 使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。

G1 将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中既压缩又释放了内存。
撤离是在多处理器上并行执行的，以减少暂停时间并增加吞吐量。
因此，对于每个垃圾回收，G1 都会不断减少碎片。这超出了先前两种方法 (垃圾收集方式) 的能力。
<font color="oragen">CMS（并发标记扫描）垃圾收集不执行压缩。并行压缩仅执行整个堆压缩，这会导致相当长的暂停时间。</font>

*重要的是要注意，G1不是实时收集器*。它很有可能达到设定的暂停时间目标，但并非绝对确定。
根据先前收集的数据，G1 估计在目标时间内可以收集多少个区域。
因此，收集器具有收集区域成本的合理准确的模型，并且收集器使用此模型来确定要收集哪些和多少个区域，同时保持在暂停时间目标之内。

G1 的首要重点是为运行需要大堆且 GC 延迟有限的应用程序的用户提供解决方案。
<font color="red">这意味着堆大小约为 6 GB 或更大，并且稳定且可预测的暂停时间低于 0.5 秒。</font>

如果应用程序具有以下一个或多个特征，则现在运行 CMS 或并行压缩的应用程序将从切换到 G1 中受益。

- 超过 *50%* 的 Java Heap 空间被活数据占据。
- 对象分配率或提升率差异很大。
- 应用程序正在经历不希望的长时间垃圾收集或压缩暂停 (长于0.5到1秒)

计划将 G1 作为并发标记扫描收集器（CMS）的长期替代产品。
将 G1 与 CMS 进行比较，可以发现使 G1 成为更好解决方案的差异。
一个区别是 G1 是压缩收集器。G1将堆划分为固定大小的区域 。
与 CMS 收集器相比，G1 提供了更多可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。
与 CMS 一样，G1 专为需要较短 GC 暂停的应用而设计。
<img src="C:\programming\dailyRecord\images\G1-collector-heap.png" alt="Grabage-First Collector Heap" style="zoom:80%;" />

G1 逻辑上是世代相传的，一组空区域被指定为逻辑年轻代。在图中，年轻一代是浅蓝色的。
分配是从逻辑上年轻的一代中完成的，当年轻一代已满时，该区域集将被垃圾收集（一个年轻的集合）。
在某些情况下，可以同时收集一组年轻区域之外的区域（深蓝色的旧区域）。这称为混合集合(*mixed collection*)
在图中，正在收集的区域用红色框标记。该图说明了混合的集合，因为同时收集了年轻区域和旧区域。
垃圾收集是一个压缩收集，它将活动对象复制到选定的最初为空的区域。
根据幸存对象的年龄，可以将对象复制到幸存者区域（标有“ S”）或复制到旧区域（未具体显示）。
标有 *H* 的区域包含巨大的对象，这些对象大于一个区域的一半，并经过特殊处理。

与 CMS 一样，G1 收集器在应用程序继续运行时会运行其部分收集，并且存在应用程序分配对象的速度快于垃圾收集器可以回收可用空间的风险。
当 G1 将活动数据从一个区域复制（撤离）到另一区域时，发生故障（Java堆耗尽）。
复制是为了压缩实时数据。
如果在疏散垃圾收集区域的过程中找不到空闲区域，则分配失败（由于没有空间从正在疏散的区域分配活动对象），并且完成了世界停止（stop-the-world STW）完整收集 (*Full collection*)。

对象可能在 G1 收集期间死亡，无法收集。
G1使用一种称为 *snapshot-at-the-beginning*（SATB）的技术来确保垃圾收集器找到所有活动对象。
SATB 指出，出于收集的目的，在并发标记（整个堆上的标记）开始时处于活动状态的任何对象都被视为处于活动状态。SATB 允许浮动垃圾的方式类似于 CMS 增量更新的方式。

###### 暂停

G1 暂停应用程序以将活动对象复制到新区域。
这些暂停可以是仅收集年轻区域的年轻收集暂停，也可以是疏散年轻和旧区域的混合收集暂停。
与 CMS 一样，在应用程序停止时，有最后的标记或注释 (*remark*) 暂停以完成标记。
CMS 也有初始标记暂停，而 G1 则作为疏散暂停的一部分进行初始标记工作。
G1 在收集的结尾具有清理阶段，该阶段部分为 STW，部分为并发。
清理阶段的 STW 部分标识空区域，并确定旧区域作为下一个收集的候选区域。

如果垃圾收集器未收集整个堆（增量收集），垃圾收集器需要知道从堆的未收集部分到正在收集的堆部分中的指针在哪里。
这通常用于分代垃圾收集器，其中堆的未收集部分通常是旧的一代，而堆的收集部分是年轻的一代。
保留此信息的数据结构（指向年轻一代对象的老一代指针）是一个可记住的集合。
一个 *card table* 是特殊类型的 *remembered set*，*Java HotSpot VM* 使用 byte 数组作为 *card table*。
每个 *byte* 的引用是为一个 *card*，卡对应堆中的地址范围。弄脏卡意味着将字节的值更改为脏值。
脏值可能在卡所覆盖的地址范围内包含从旧一代到年轻一代的新指针。

处理卡意味着查看卡以查看是否存在老一代指针到年轻一代指针，并且可能会对这些信息进行某些处理，例如将其传输到另一个数据结构。

G1 具有并发标记阶段，该阶段标记从应用程序中找到的活动对象。
并发标记从疏散暂停（完成初始标记工作）结束到标记为止。
并发清理阶段将集合清空的区域添加到空闲区域列表中，并清除记住的那些区域集。
此外，并发优化线程将根据需要运行，以处理已被应用程序写入弄脏并且可能具有跨区域引用的卡表条目。

###### 开始并发收集周期

由前面提及，*young* 和 *old* 区域的垃圾收集都是以混合的收集方法。
为了收集旧区域，G1 对堆中的活动对象进行了完整标记，这种标记是通过并发标记阶段完成的。
当整个 Java 堆的占用量达到参数 *InitiatingHeapOccupancyPercent* 的值时，将开始并发标记阶段。
使用命令行选项 *-XX:InitiatingHeapOccupancyPercent=<NN>* 设置此参数的值。
*InitiatingHeapOccupancyPercent* 的默认值为 45。

##### 暂停时间

在收集结束时，G1 选择要在下一个收集（收集集）中收集的区域。
集合集将包含年轻区域（其大小的总和决定了逻辑年轻代的大小）。
G1 部分地通过选择收集集中的年轻区域的数量来控制 GC 暂停的长度。
您可以像其他垃圾回收器一样在命令行上指定年轻代的大小，但是这样做可能会妨碍 G1 达到目标暂停时间的能力。
除了暂停时间目标外，您还可以指定可能发生暂停的时间段的长度。
您可以在此时间跨度（GCPauseIntervalMillis）以及暂停时间目标中指定最小的转换器使用量
*MaxGCPauseMillis* 的默认值为 200 毫秒。
GCPauseIntervalMillis(0) 的默认值等效于时间跨度上的任何要求。

##### G1 调整

区域大小可能从1 MB到32 MB不等，具体取决于堆大小。目标是不超过2048 个区域。
伊甸园 (eden)，幸存者 (survivor) 和 前几代 (old generation) 是这些地区的逻辑集合，并不相邻。
G1 GC 具有尝试达到的暂停时间目标（软实时）。
在年轻代收集，G1 GC 会调整其年轻一代（伊甸园和幸存者的大小），以达到柔和 (*soft*) 的实时目标。

*G1 GC* 通过将活动对象从一个或多个区域集（称为集合集（CSet））增量并行复制到一个或多个不同的新区域中来实现压缩，从而减少了堆碎片。
目标是从包含最大可回收空间的那些区域开始，尽可能多地回收堆空间，同时尝试不超过暂停时间目标（首先是垃圾）。

G1 GC 使用独立的记忆集（RSets）来将引用跟踪到区域中。
独立的 RSets 可以并行且独立地收集区域，因为仅需扫描区域的 RSet 来查找对该区域的引用，而不是整个堆的引用。G1 GC 使用写后 (*post-write*) 屏障来记录对堆的更改并更新 RSets。

在G1 GC收集到足够数量的旧区域（通过多个混合垃圾收集）之后，G1恢复执行新的垃圾收集，直到下一个标记周期完成。

###### 标记周期阶段

- 初始标记阶段
  G1 GC在此阶段标记根。此阶段由常规（STW）的年轻垃圾回收承载。
- 根区扫描阶段
  G1 GC 扫描在初始标记阶段标记的幸存者区域，以获取对旧一代的引用，并标记所引用的对象。
  该阶段与应用程序（不是STW）同时运行，并且必须在下一个 STW 年轻垃圾收集开始之前完成。
- 并发标记阶段
  G1 GC 在整个堆中找到可访问的（活动的）对象。此阶段与应用程序同时发生，并且可以被 STW 年轻的垃圾回收中断。
- 再次标记阶段
  此阶段是 STW 收集，有助于完成标记周期。 G1 GC 耗尽 SATB 缓冲区，跟踪未访问的活动对象，并执行参考处理。
- 清理阶段
  在最后阶段，G1 GC 执行记帐和 RSet 清理的 STW 操作。
  在记帐期间，G1 GC 会识别出完全空闲的区域和混合垃圾收集候选对象。
  清除阶段在重置并将空闲区域返回到空闲列表时，部分处于并发状态。

G1 GC是具有默认设置的自适应垃圾收集器，可使其无需修改即可高效工作。

`-XX:MaxGCPauseMillis=200` 为所需的最大暂停时间设置目标值。

###### 推荐配置

- Young Generation Size
  避免使用 `-Xmn` 选项或任何其他相关选项（例如 `-XX:NewRatio`）显式设置年轻代大小。
  固定年轻一代的大小会覆盖目标暂停时间目标。
- Pause Time Goals
  当您评估或调整任何垃圾收集时，总会存在延迟与吞吐量之间的权衡。