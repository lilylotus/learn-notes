进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元
进程(Process)是计算机中的程序关于某数据集合的一次运动，是系统进行资源分配和调度的基本单位，是操作系统的结构基础。

线程是轻量级的进程，是程序执行的最小单位。

New ---> Runnable (<--> Blocked) (<--> Waiting) --> Running --> Terminated

存储资源是操作系统由虚拟内存机制来管理和分配的。进程是操作系统分配存储资源的最小单元。
每个进程有独立的虚拟内存地址空间，会真正地拥有独立与父进程之外的物理内存。
并且由于进程拥有独立的内存地址空间，导致了进程之间无法利用直接的内存映射进行进程间通信。

线程解决的最大问题就是它可以很简单地表示共享资源的问题，这里说的资源指的是存储器资源，
资源最后都会加载到物理内存，一个进程的所有线程都是共享这个进程的同一个虚拟地址空间的，
也就是说从线程的角度来说，它们看到的物理资源都是一样的，这样就可以通过共享变量的方式来表示共享资源，
也就是直接共享内存的方式解决了线程通信的问题。而线程也表示一个独立的逻辑流，这样就完美解决了进程的一个大难题。

冯诺依曼结构把计算机系统抽象成 CPU + 存储器 + IO，那么计算机资源分为两种： 计算资源 和 存储资源

------------------------------------------------
一. 终止线程 (Thread 的 stop() 方法， 注：废弃)
此方法太过于暴力，强行把执行到一半的线程终止，导致数据不一致问题。
在结束线程时，会直接终止线程，并且会立即释放掉这个线程的所有锁。
锁的释放可能导致另一个等待该锁的读线程读到了数据不一致的对象，发生数据错误。

二. 线程中断
在 java 当中，线程中断是一种重要的线程协作机制。而且线程中断不会立即退出，而是给线程发送一个通知，
告知目标线程希望退出，至于目标线程如何处理就由它自己决定。
注意：即使被设置了中断，线程本身不会自己停止。

public void Thread.interrupt();  // 中断线程，设置中断标志位
public boolean Thread.isInterrupted();  // 判断是否中断，检查标志位
public static void Thread.interrupted();  // 判断释放被中断，并且清除中断状态

注意： Thread.sleep(1000) 会抛出 InterruptedException 中断异常而不是运行时异常，
所以程序必须捕获并处理它，当线程在休眠时被中断就会产生此异常。

Thread.sleep() 方法由于中断抛出异常，此时会清除中断标记，如果不处理，下次循环就无法捕获此中断，故在异常处理中再次设置中断标记位。

三. 等待 (wait) 和通知 (notify)
public final void wait() ;
public final native void nofity();

object.notify() 会从等待队列当中随机选择一个唤醒，并且此选择是不公平的。
object.notifyAll() 会唤醒等待队列当中的所有线程，而不是一个。

注意：Object.wait() 方法不可随便调用，必须包含在对应的 synchronized 语句中。
wait() 和 notify() 都需要首先获取目标对象的一个监视器。监视器会在 wait() 方法后释放掉。
在调用 notify() 之前，也必须获取对象的监视器。

注意： Object.wait() 和 Thread.sleep() 方法都可以让线程等待若干时间，但是除了 wait() 可以
被唤醒外，另外一个区别在于 wait() 方法会释放目标对象的锁，而 sleep() 不会释放任何锁。

四. 挂起 (suspend) 和继续执行 (resume) [已经弃用，不推荐使用]
原因: suspend 挂起线程时不会释放任何资源，其他任何线程想要访问被他占用的锁时，都会被阻塞，
无法正常运行，要对应的 resume 操作才能正常运行。
注意：如何 resume 在 suspend 之前就执行那么被挂起的线程就很难在执行。

五. 等待线程结束 (join) 和谦让 (yield)

public final void join()
public final synchronized void join(long mills)
会让调用线程在当期对象上进行等待。

yield() 会使当前线程让出 CUP。

六. volatile 与 java 内存模型 (JMM)
java 内存模型围绕着原子性、有序性、可见性展开。
volatile 易变的，不稳定的，保证变量的可见性特点。
注意： volatile 并不能替代锁，无法保证一些复合的操作原子性。

七. 线程组

八. 守护线程　(daemon)

九. 线程安全和　synchronized
volatile 并不能保证线程安全，只能确保一个线程修改数据后，另一个线程可以看到修改，
但是两个线程同时修改一个数据时却依然会产生冲突。

synchronized 用法：
１．　指定枷锁对象，对给定的对象加锁，进入同步代码前要获得给定对象锁。
２．　直接作用于实例方法，相当于给实例加锁，进入同步代码前要获得当前实例的锁。
３．　直接作用于静态方法，相当于个类加锁，进入同步代码前要获得当前类的锁。

十. 并发下的　ＡrrayList, HashMap
ArrayList 是一个线程不安全的容器，在多线程当中使用可能或导致程序出错。
常见情况：
１．　程序正常，ArrayList 操作正常
２．　程序抛出异常，因为　ArrayList 扩容过程中，内部一致性被破坏，由于没锁保护，
另一个线程访问到了不一致的内部状态，导致越界问题
３．　非常隐蔽的问题，ArrayList 操作结果和预期不符合。多线程同时访问同一位置导致赋值问题。
改进方法，使用线程安全的　Vector 代替。

HashMap 同样是线程不安全的，在多线程下会出现十分诡异的问题。
常见情况：
１. 程序正常结束，结果符合预期。
２．　程序正常结束，结果与预期不符合。
３．　程序永远无法结束，同时占用多个　CPU 导致死循环，JDK ８中死循环问题不存在。