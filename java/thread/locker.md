#### 1. java 锁分类

##### 1.1 悲观锁、乐观锁

- *悲观锁*
  认为读少写多，每次读写资源时都会上锁，其它线程需要一直阻塞直到获取锁，java 中典型的悲观锁就是 `synchronizied`，AQS 框架下的锁会先进行 `CAS` （比较交换，原子操作）获取锁，获取不到才会转换成悲观锁，如 `ReentrantLock`。
- *乐观锁*
  乐观思想，认为读多写少，在读资源时不上锁，但在写资源时会先判断资源是否被他人修改过，一般通过资源版本号来判断：若资源更新后的版本号与期望版本号一致，则未被修改，否则已被修改。

##### 1.2 锁分类

1. *偏向锁*
   运行过程中，若只有一个线程持有锁，没有其它线程与之争夺，那么锁就会偏向于该线程，此锁称为偏向锁，此时只有单个线程，并不需同步操作，能提高程序运行性能。 如果后来有其他线程来争夺锁，那么 jvm 会将该持有偏向锁的线程挂起，消除它的偏向锁，将锁升级成 **轻量级锁**。

2. *轻量级锁*
   轻量级锁是相对于重量级锁来说的，使用轻量级锁时只需将 *MarkWord* 部分字节更新指向线程栈（每个线程都有自己的栈）中的 *Lock Record*，若更新成功，则获取轻量级锁成功，否则说明目前已经有线程获取了轻量级锁，此时发生了竞争，需要升级成**重量级锁**。轻量级锁也称为乐观锁。

   轻量级锁主要有自旋锁和自适应自旋锁。

3. *自旋锁*
   如果持有锁的线程能在短时间内释放锁，那么其它线程就不用进入阻塞状态（阻塞和唤醒线程需要操作系统从用户态切换到核心态，开销较大），只需要等待一下（自旋），等到锁被释放再去争夺锁。但是自旋需要占用 cpu，一旦自旋时间过长，则会造成 cpu 浪费，所以需要设置一个最大自旋时间，自旋超过最大时间的线程依然会进入阻塞状态。

4. *自适应自旋锁*
   自适应意味着线程自旋时间是非固定的，会根据情况动态改变。如线程自旋很少成功获得过锁，那么以后可能会减少自旋时间，甚至忽略自旋，避免浪费 cpu 资源；对于刚刚自旋获得过锁的线程来说，下一次自旋获得锁的可能性较大，所以会适当增加自旋时间。

5. *重量级锁*
   由轻量级锁升级而来，也称为互斥锁，当系统检测到是重量级锁后，会将等待获取锁的线程置于阻塞态，不会占用 cpu，但是阻塞和唤醒线程需要操作系统从用户态切换到核心态，开销较大。重量级锁也叫悲观锁。

##### 1.3 java 每个对象都有两个池，锁池/等待池

1. *锁池*

   锁被某个线程持有时，其他争夺锁的线程在该线程释放锁之前会进入锁池。

2. *等待池*
   持有锁的线程在调用对象锁的 *wait()* 后会释放锁，并进入等待池。当其他线程调用对象锁的 *notify()* 或者*notifyAll()* 后，被唤醒的线程会从等待池进入锁池。 上文说到 synchronized 是 java 中的重量级锁，它是一种独占锁（线程获取锁后其它线程需要阻塞），除了 synchronized，ReentrantLock 也是独占锁。

